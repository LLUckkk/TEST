{
  "input_header": "def get_text_embedding(self,text: str):",
  "input_docstring": null,
  "output_code": "    def get_text_embedding(self,text: str):\n            if BASE_URL:\n                client = openai.OpenAI(\n                    api_key=OPENAI_API_KEY,\n                    base_url=BASE_URL,\n                )\n            else:\n                client = openai.OpenAI(\n                    api_key=OPENAI_API_KEY\n                )\n\n            if len(text)>8191:\n                  text = text[:8190]\n            response = client.embeddings.create(input = text, model=\"text-embedding-ada-002\").model_dump()\n            embedding = response['data'][0]['embedding']\n            log_and_print_online(\n            \"Get text embedding from {}:\\n**[OpenAI_Usage_Info Receive]**\\nprompt_tokens: {}\\ntotal_tokens: {}\\n\".format(\n                response[\"model\"],response[\"usage\"][\"prompt_tokens\"],response[\"usage\"][\"total_tokens\"]))\n            self.text_prompt_tokens += response[\"usage\"][\"prompt_tokens\"]\n            self.text_total_tokens += response[\"usage\"][\"total_tokens\"]\n            self.prompt_tokens += response[\"usage\"][\"prompt_tokens\"]\n            self.total_tokens += response[\"usage\"][\"total_tokens\"]\n\n            return embedding",
  "input_contexts": [
    {
      "id": "OpenBMB_ChatDev_1003_1",
      "input_code": "def get_consistency(directory):\n    def remove_comments(string):\n        def remove_comments_by_regex(string, regex):\n            lines = string.split(\"\\n\")\n            lines = [line for line in lines if not line.strip().startswith(\"#\")]\n            string = \"\\n\".join(lines)\n            comments = []\n            matches = re.finditer(regex, string, re.DOTALL)\n            for match in matches:\n                group1 = match.group(1)\n                comments.append(group1)\n            for comment in comments + [\"''''''\\n\"]:\n                string = string.replace(comment, \"\")\n            return string\n\n        string = remove_comments_by_regex(string, r\"'''(.*?)'''\")\n        string = remove_comments_by_regex(string, r\"\\\"\\\"\\\"(.*?)\\\"\\\"\\\"\")\n        return string\n\n    def get_text_embedding(text: str):\n        if text == \"\":\n            text = \"None\"\n        ada_embedding = client.embeddings.create(input=text, model=\"text-embedding-ada-002\").model_dump()['data'][0]['embedding']\n        return ada_embedding\n\n    def get_code_embedding(code: str):\n        if code == \"\":\n            code = \"#\"\n        ada_embedding = client.embeddings.create(input=code, model=\"text-embedding-ada-002\").model_dump()['data'][0]['embedding']\n        return ada_embedding\n\n    def get_cosine_similarity(embeddingi, embeddingj):\n        embeddingi = np.array(embeddingi)\n        embeddingj = np.array(embeddingj)\n        cos_sim = embeddingi.dot(embeddingj) / (np.linalg.norm(embeddingi) * np.linalg.norm(embeddingj))\n        return cos_sim\n\n    assert os.path.isdir(directory)\n    files = getFilesFromType(directory, \".txt\")\n    if len(files) == 0:\n        print()\n    filepath = files[0]\n    task = open(filepath).read().strip()\n    codes = get_code(directory)\n    codes = remove_comments(codes)\n\n    text_embedding = get_text_embedding(task)\n    code_embedding = get_code_embedding(codes)\n    task_code_alignment = get_cosine_similarity(text_embedding, code_embedding)\n\n    return task_code_alignment\n"
    },
    {
      "id": "OpenBMB_ChatDev_1003_2",
      "input_code": "    def _pairwise_estimate(self, vi: Node, vj: Node):\n\n        if vi.value == 0.0:\n            return 0.0\n\n        pathNodes, pathEdges = self.graph.find_shortest_path(vi.mID, vj.mID)\n        distance_weight = 1.0 / len(pathEdges) if len(pathEdges) != 0 else 1.0\n\n        codes = Codes(vi.code)\n        codes._rewrite_codes()\n        (exist_bugs_flag, test_reports) = codes._run_codes()\n        compile_weight = 0.0 if exist_bugs_flag else 1.0\n\n        if compile_weight == 0.0:\n            return 0.0\n\n        maximum_degree = max([self.graph.nodes[mid].degree for mid in self.graph.nodes.keys()])\n        degree_weight = vi.degree * 1.0 / maximum_degree\n\n        if degree_weight == 0.0:\n            return 0.0\n\n        start_time = time.time()\n        vi_code_emb = self.embedding_method.get_code_embedding(vi.code) if vi.embedding is None else vi.embedding\n        if vi.embedding is None:\n            end_time =time.time()\n            log_and_print_online(\"DONE:get node embedding\\ntime cost:{}\\n\".format(end_time-start_time))\n        vi.embedding = vi_code_emb\n        \n        start_time = time.time()\n        vj_code_emb = self.embedding_method.get_code_embedding(vj.code) if vj.embedding is None else vj.embedding\n        if vj.embedding is None:\n            end_time =time.time()\n            log_and_print_online(\"DONE:get node embedding\\ntime cost:{}\\n\".format(end_time-start_time))\n        vj.embedding = vj_code_emb\n        code_code_cos_sim = self.get_cosine_similarity(vi_code_emb, vj_code_emb)\n\n        if code_code_cos_sim == 0.0:\n            return 0.0\n\n        filenames = os.listdir(self.directory)\n        filename = [filename for filename in filenames if filename.endswith(\".prompt\")][0]\n        task_prompt = open(os.path.join(self.directory, filename), \"r\").read().strip()\n        start_time = time.time()\n        task_emb = self.embedding_method.get_text_embedding(task_prompt) if self.graph.task_embedding is None else self.graph.task_embedding\n        if self.graph.task_embedding is None:\n            end_time =time.time()\n            log_and_print_online(\"DONE:get task prompt embedding\\ntime cost:{}\\n\".format(end_time-start_time))\n        self.graph.task = task_prompt\n        self.graph.task_embedding = task_emb\n        code_text_cos_sim = self.get_cosine_similarity(vi_code_emb, task_emb)\n\n        if code_text_cos_sim == 0.0:\n            return 0.0\n\n        assert distance_weight >= 0.0 and distance_weight <= 1.0\n        assert compile_weight >= 0.0 and compile_weight <= 1.0\n        assert degree_weight >= 0.0 and degree_weight <= 1.0\n\n        distance = vj.version - vi.version\n\n        if distance == 0:\n            return 1\n        else:\n            return code_code_cos_sim * 1.0 / distance * code_text_cos_sim * compile_weight * degree_weight\n"
    },
    {
      "id": "OpenBMB_ChatDev_1003_4",
      "input_code": "    def _set_embedding(self,experience):\n        graph = experience.graph\n        edge_start_time = time.time()\n        for edge in graph.edges:\n            if edge.embedding is None:\n                start_time =time.time()\n                edge.embedding = self.memory_data[\"All\"].embedding_method.get_text_embedding(edge.instruction)\n                end_time = time.time()\n                log_and_print_online(\"DONE: get edge embedding\\ntime cost:{}\\n\".format(end_time-start_time))\n        edge_duration =  time.time() - edge_start_time\n        log_and_print_online(\"DONE: got all EDGE embeddings\\nEDGE embedding time cost:{}\\n\".format(edge_duration))\n        node_start_time =  time.time()\n        for node_id in graph.nodes:\n            node = graph.nodes[node_id]\n            if node.embedding is None:\n                start_time = time.time()\n                node.embedding = self.memory_data[\"All\"].embedding_method.get_code_embedding(node.code)\n                end_time = time.time()\n                log_and_print_online(\"DONE: get node embedding\\ntime cost:{}\\n\".format(end_time-start_time))\n        node_duration = ( time.time() - node_start_time)\n        log_and_print_online(\"DONE: got all NODE embeddings\\nNODE embedding time cost:{}\\n\".format(node_duration))\n        exp_start_time = time.time()\n        for exp in experience.experiences:\n            if exp.embedding is None:\n                start_time = time.time()\n                exp.embedding = self.memory_data[\"All\"].embedding_method.get_text_embedding(exp.instructionStar)\n                end_time = time.time()\n                log_and_print_online(\"DONE: get exprience embedding\\ntime cost:{}\\n\".format(end_time-start_time))\n        exp_duration = ( time.time() - exp_start_time)\n        log_and_print_online(\"DONE: got all EXPERIENCE embeddings\\nEXPERIENCE embedding time cost:{}\\n\".format(exp_duration))\n        duration = edge_duration + node_duration + exp_duration\n        log_and_print_online(\"All embedding DONE\\ntime cost:{}\\n\".format(duration))\n"
    },
    {
      "id": "OpenBMB_ChatDev_1003_3",
      "input_code": "    def search_code(self, text_query, k:int):\n        \n\n        if self._get_memory_count() == 0 or text_query == None or k == 0:\n            return None            \n          \n        else :\n            text_query = self.embedding_method.get_text_embedding(text_query)\n            if isinstance(text_query,list):\n                text_query=np.array(text_query,dtype=np.float32)\n            text_query = text_query.reshape(1,-1)\n\n            text_embeddings = [exp.get(\"embedding\") for t in self.content for exp in t[\"experiences\"]]\n            text_embedding_data = np.array(text_embeddings, dtype=np.float32)\n\n            faiss.normalize_L2(text_embedding_data)\n            faiss.normalize_L2(text_query)\n            total_instructionStar = text_embedding_data.shape[0]\n            index = faiss.IndexFlatL2(text_embedding_data.shape[1])\n            index.add(text_embedding_data)\n            distances, indices = index.search(text_query, total_instructionStar)\n\n\n            similarities = 1-(1/2)*distances\n\n            code_node_list = [node for t in self.content for node in t[\"nodes\"]]\n            targetMIDs = []\n            target_code = []\n            task_list = []\n            task_dir_list = []\n            filtered_similarities = []\n            experience_list = [experience for t in self.content for experience in t[\"experiences\"]]\n            counter = 0\n\n            added_set = set()\n            for i in range(total_instructionStar):\n                index =  indices[0][i]\n                similarity = similarities[0][i]\n                if index != -1 and counter < k:\n                    if similarity <= self.code_thresh:\n                        break\n                    else:\n                        mid = experience_list[index].get(\"targetMID\")\n                        if mid not in added_set:\n                            targetMIDs.append(mid)\n                            added_set.add(mid)\n                            counter += 1\n                            filtered_similarities.append(str(similarity))\n                else:\n                    break\n\n            for targetMID in targetMIDs:\n                for code_node in code_node_list:\n                    if targetMID == code_node.get(\"mID\"):\n                        target_code.append(code_node.get(\"code\"))\n                        task, task_dir = self._get_task_from_target(targetMID)\n                        task_list.append(task)\n                        task_dir_list.append(task_dir)\n            filtered_similarities = \",\".join(filtered_similarities)\n            return target_code, filtered_similarities, targetMIDs, task_list, task_dir_list\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport openai\n\n<testcase_1>\ntext = \"Hello, how are you today?\"\n\n<testcase_2>\ntext = \"The quick brown fox jumps over the lazy dog.\"\n\n<testcase_3>\ntext = \"Artificial intelligence is transforming the world in unprecedented ways.\"\n\n<testcase_4>\ntext = \"Python is a versatile programming language used for web development, data analysis, artificial intelligence, and more.\"\n\n<testcase_5>\ntext = \"In a distant future, humanity has colonized Mars and established thriving communities.\""
  ],
  "gpt_output": "<needimport>\nimport openai\n\n<testcase_1>\ntext = \"Hello, how are you today?\"\n\n<testcase_2>\ntext = \"The quick brown fox jumps over the lazy dog.\"\n\n<testcase_3>\ntext = \"Artificial intelligence is transforming the world in unprecedented ways.\"\n\n<testcase_4>\ntext = \"Python is a versatile programming language used for web development, data analysis, artificial intelligence, and more.\"\n\n<testcase_5>\ntext = \"In a distant future, humanity has colonized Mars and established thriving communities.\"",
  "needimport": "import openai\n\n",
  "test_results": {
    "ans1": null,
    "ans2": null,
    "ans3": null,
    "ans4": null,
    "ans5": null
  }
}