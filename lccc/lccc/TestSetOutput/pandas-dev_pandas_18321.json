{
  "input_header": "def merge_cells(request):",
  "input_docstring": null,
  "output_code": "def merge_cells(request):\n    return request.param",
  "input_contexts": [
    {
      "id": "pandas-dev_pandas_18321_1",
      "input_code": "    def _write_cells(\n        self,\n        cells,\n        sheet_name: str | None = None,\n        startrow: int = 0,\n        startcol: int = 0,\n        freeze_panes: tuple[int, int] | None = None,\n    ) -> None:\n        sheet_name = self._get_sheet_name(sheet_name)\n\n        _style_cache: dict[str, dict[str, Serialisable]] = {}\n\n        if sheet_name in self.sheets and self._if_sheet_exists != \"new\":\n            if \"r+\" in self._mode:\n                if self._if_sheet_exists == \"replace\":\n                    old_wks = self.sheets[sheet_name]\n                    target_index = self.book.index(old_wks)\n                    del self.book[sheet_name]\n                    wks = self.book.create_sheet(sheet_name, target_index)\n                elif self._if_sheet_exists == \"error\":\n                    raise ValueError(\n                        f\"Sheet '{sheet_name}' already exists and \"\n                        f\"if_sheet_exists is set to 'error'.\"\n                    )\n                elif self._if_sheet_exists == \"overlay\":\n                    wks = self.sheets[sheet_name]\n                else:\n                    raise ValueError(\n                        f\"'{self._if_sheet_exists}' is not valid for if_sheet_exists. \"\n                        \"Valid options are 'error', 'new', 'replace' and 'overlay'.\"\n                    )\n            else:\n                wks = self.sheets[sheet_name]\n        else:\n            wks = self.book.create_sheet()\n            wks.title = sheet_name\n\n        if validate_freeze_panes(freeze_panes):\n            freeze_panes = cast(tuple[int, int], freeze_panes)\n            wks.freeze_panes = wks.cell(\n                row=freeze_panes[0] + 1, column=freeze_panes[1] + 1\n            )\n\n        for cell in cells:\n            xcell = wks.cell(\n                row=startrow + cell.row + 1, column=startcol + cell.col + 1\n            )\n            xcell.value, fmt = self._value_with_fmt(cell.val)\n            if fmt:\n                xcell.number_format = fmt\n\n            style_kwargs: dict[str, Serialisable] | None = {}\n            if cell.style:\n                key = str(cell.style)\n                style_kwargs = _style_cache.get(key)\n                if style_kwargs is None:\n                    style_kwargs = self._convert_to_style_kwargs(cell.style)\n                    _style_cache[key] = style_kwargs\n\n            if style_kwargs:\n                for k, v in style_kwargs.items():\n                    setattr(xcell, k, v)\n\n            if cell.mergestart is not None and cell.mergeend is not None:\n                wks.merge_cells(\n                    start_row=startrow + cell.row + 1,\n                    start_column=startcol + cell.col + 1,\n                    end_column=startcol + cell.mergeend + 1,\n                    end_row=startrow + cell.mergestart + 1,\n                )\n\n                if style_kwargs:\n                    first_row = startrow + cell.row + 1\n                    last_row = startrow + cell.mergestart + 1\n                    first_col = startcol + cell.col + 1\n                    last_col = startcol + cell.mergeend + 1\n\n                    for row in range(first_row, last_row + 1):\n                        for col in range(first_col, last_col + 1):\n                            if row == first_row and col == first_col:\n                                continue\n                            xcell = wks.cell(column=col, row=row)\n                            for k, v in style_kwargs.items():\n                                setattr(xcell, k, v)\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport pandas as pd\n\n<testcase_1>\nrequest = pd.Series({\"param\": \"merge\"})\n\n<testcase_2>\nrequest = pd.Series({\"param\": \"split\"})\n\n<testcase_3>\nrequest = pd.Series({\"param\": \"combine\"})\n\n<testcase_4>\nrequest = pd.Series({\"param\": \"divide\"})\n\n<testcase_5>\nrequest = pd.Series({\"param\": \"append\"})"
  ],
  "gpt_output": "<needimport>\nimport pandas as pd\n\n<testcase_1>\nrequest = pd.Series({\"param\": \"merge\"})\n\n<testcase_2>\nrequest = pd.Series({\"param\": \"split\"})\n\n<testcase_3>\nrequest = pd.Series({\"param\": \"combine\"})\n\n<testcase_4>\nrequest = pd.Series({\"param\": \"divide\"})\n\n<testcase_5>\nrequest = pd.Series({\"param\": \"append\"})",
  "needimport": "import pandas as pd\n\n",
  "test_results": {
    "ans1": "merge",
    "ans2": "split",
    "ans3": "combine",
    "ans4": "divide",
    "ans5": "append"
  }
}