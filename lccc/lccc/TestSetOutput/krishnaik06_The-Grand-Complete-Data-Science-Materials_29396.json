{
  "input_header": "def score_family(self, families, family2):",
  "input_docstring": "Return a match score between the list of font families in\n*families* and the font family name *family2*.\n\nAn exact match at the head of the list returns 0.0.\n\nA match further down the list will return between 0 and 1.\n\nNo match will return 1.0.",
  "output_code": "    def score_family(self, families, family2):\n        \n        if not isinstance(families, (list, tuple)):\n            families = [families]\n        elif len(families) == 0:\n            return 1.0\n        family2 = family2.lower()\n        step = 1 / len(families)\n        for i, family1 in enumerate(families):\n            family1 = family1.lower()\n            if family1 in font_family_aliases:\n                options = [*map(str.lower, self._expand_aliases(family1))]\n                if family2 in options:\n                    idx = options.index(family2)\n                    return (i + (idx / len(options))) * step\n            elif family1 == family2:\n                return i * step\n        return 1.0",
  "input_contexts": [
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_29396_1",
      "input_code": "    def _findfont_cached(self, prop, fontext, directory, fallback_to_default,\n                         rebuild_if_missing, rc_params):\n\n        prop = FontProperties._from_any(prop)\n\n        fname = prop.get_file()\n        if fname is not None:\n            return fname\n\n        if fontext == 'afm':\n            fontlist = self.afmlist\n        else:\n            fontlist = self.ttflist\n\n        best_score = 1e64\n        best_font = None\n\n        _log.debug('findfont: Matching %s.', prop)\n        for font in fontlist:\n            if (directory is not None and\n                    Path(directory) not in Path(font.fname).parents):\n                continue\n            score = (self.score_family(prop.get_family(), font.name) * 10\n                     + self.score_style(prop.get_style(), font.style)\n                     + self.score_variant(prop.get_variant(), font.variant)\n                     + self.score_weight(prop.get_weight(), font.weight)\n                     + self.score_stretch(prop.get_stretch(), font.stretch)\n                     + self.score_size(prop.get_size(), font.size))\n            _log.debug('findfont: score(%s) = %s', font, score)\n            if score < best_score:\n                best_score = score\n                best_font = font\n            if score == 0:\n                break\n\n        if best_font is None or best_score >= 10.0:\n            if fallback_to_default:\n                _log.warning(\n                    'findfont: Font family %s not found. Falling back to %s.',\n                    prop.get_family(), self.defaultFamily[fontext])\n                for family in map(str.lower, prop.get_family()):\n                    if family in font_family_aliases:\n                        _log.warning(\n                            \"findfont: Generic family %r not found because \"\n                            \"none of the following families were found: %s\",\n                            family, \", \".join(self._expand_aliases(family)))\n                default_prop = prop.copy()\n                default_prop.set_family(self.defaultFamily[fontext])\n                return self.findfont(default_prop, fontext, directory,\n                                     fallback_to_default=False)\n            else:\n                return ValueError(f\"Failed to find font {prop}, and fallback \"\n                                  f\"to the default font was disabled\")\n        else:\n            _log.debug('findfont: Matching %s to %s (%r) with score of %f.',\n                       prop, best_font.name, best_font.fname, best_score)\n            result = best_font.fname\n\n        if not os.path.isfile(result):\n            if rebuild_if_missing:\n                _log.info(\n                    'findfont: Found a missing font file.  Rebuilding cache.')\n                new_fm = _load_fontmanager(try_read_cache=False)\n                vars(self).update(vars(new_fm))\n                return self.findfont(\n                    prop, fontext, directory, rebuild_if_missing=False)\n            else:\n                return ValueError(\"No valid font could be found\")\n\n        return _cached_realpath(result)\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport os\nfrom pathlib import Path\n\n<testcase_1>\nfamilies = [\"Arial\", \"Helvetica\", \"Times New Roman\"]\nfamily2 = \"Helvetica\"\n\n<testcase_2>\nfamilies = [\"Courier New\", \"Comic Sans MS\", \"Georgia\"]\nfamily2 = \"Verdana\"\n\n<testcase_3>\nfamilies = [\"Times New Roman\", \"Arial\", \"Courier New\"]\nfamily2 = \"Times New Roman\"\n\n<testcase_4>\nfamilies = [\"Verdana\", \"Tahoma\", \"Impact\"]\nfamily2 = \"Impact\"\n\n<testcase_5>\nfamilies = [\"Comic Sans MS\", \"Georgia\", \"Palatino\"]\nfamily2 = \"Georgia\""
  ],
  "gpt_output": "<needimport>\nimport os\nfrom pathlib import Path\n\n<testcase_1>\nfamilies = [\"Arial\", \"Helvetica\", \"Times New Roman\"]\nfamily2 = \"Helvetica\"\n\n<testcase_2>\nfamilies = [\"Courier New\", \"Comic Sans MS\", \"Georgia\"]\nfamily2 = \"Verdana\"\n\n<testcase_3>\nfamilies = [\"Times New Roman\", \"Arial\", \"Courier New\"]\nfamily2 = \"Times New Roman\"\n\n<testcase_4>\nfamilies = [\"Verdana\", \"Tahoma\", \"Impact\"]\nfamily2 = \"Impact\"\n\n<testcase_5>\nfamilies = [\"Comic Sans MS\", \"Georgia\", \"Palatino\"]\nfamily2 = \"Georgia\"",
  "needimport": "import os\nfrom pathlib import Path\n\n",
  "test_results": {
    "ans1": 0.3333333333333333,
    "ans2": 1.0,
    "ans3": 0.0,
    "ans4": 0.6666666666666666,
    "ans5": 0.3333333333333333
  }
}