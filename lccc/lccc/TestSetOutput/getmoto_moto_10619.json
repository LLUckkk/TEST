{
  "input_header": "def parse_key_name(pth: str) -> str:",
  "input_docstring": null,
  "output_code": "def parse_key_name(pth: str) -> str:\n    return pth[1:] if pth.startswith(\"/\") else pth",
  "input_contexts": [
    {
      "id": "getmoto_moto_10619_6",
      "input_code": "    def put_object_tagging(self) -> TYPE_RESPONSE:\n        key_name = self.parse_key_name()\n        version_id = self._get_param(\"versionId\")\n        key_to_tag = self.backend.get_object(\n            self.bucket_name, key_name, version_id=version_id\n        )\n        tagging = self._tagging_from_xml()\n        self.backend.put_object_tagging(key_to_tag, tagging, key_name)\n\n        response_headers = self._get_cors_headers_other()\n        self._get_checksum(response_headers)\n        return 200, response_headers, \"\"\n"
    },
    {
      "id": "getmoto_moto_10619_3",
      "input_code": "    def _get_key(self, validate_storage_class: bool = True) -> Tuple[FakeKey, bool]:\n        key_name = self.parse_key_name()\n        version_id = self.querystring.get(\"versionId\", [None])[0]\n        if_modified_since = self.headers.get(\"If-Modified-Since\")\n        if_match = self.headers.get(\"If-Match\")\n        if_none_match = self.headers.get(\"If-None-Match\")\n        if_unmodified_since = self.headers.get(\"If-Unmodified-Since\")\n\n        key = self.backend.get_object(self.bucket_name, key_name, version_id=version_id)\n        if key is None and version_id is None:\n            raise MissingKey(key=key_name)\n        elif key is None:\n            raise MissingVersion()\n        if validate_storage_class and key.storage_class in ARCHIVE_STORAGE_CLASSES:\n            if 'ongoing-request=\"false\"' not in key.response_dict.get(\n                \"x-amz-restore\", \"\"\n            ):\n                raise InvalidObjectState(storage_class=key.storage_class)\n        if if_unmodified_since:\n            if_unmodified_since = str_to_rfc_1123_datetime(if_unmodified_since)\n            if key.last_modified.replace(microsecond=0) > if_unmodified_since:\n                raise PreconditionFailed(\"If-Unmodified-Since\")\n        if if_match and key.etag not in [if_match, f'\"{if_match}\"']:\n            raise PreconditionFailed(\"If-Match\")\n        not_modified = False\n        if if_modified_since:\n            if_modified_since = str_to_rfc_1123_datetime(if_modified_since)\n            if key.last_modified.replace(microsecond=0) <= if_modified_since:\n                not_modified = True\n        if if_none_match and key.etag in [if_none_match, f'\"{if_none_match}\"']:\n            not_modified = True\n        return key, not_modified\n"
    },
    {
      "id": "getmoto_moto_10619_9",
      "input_code": "    def put_object_retention(self) -> TYPE_RESPONSE:\n        version_id = self._get_param(\"versionId\")\n        bucket = self.backend.get_bucket(self.bucket_name)\n        lock_enabled = bucket.object_lock_enabled\n        key_name = self.parse_key_name()\n\n        if not lock_enabled:\n            raise LockNotEnabled\n        retention = self._mode_until_from_body()\n        self.backend.put_object_retention(\n            self.bucket_name, key_name, version_id=version_id, retention=retention\n        )\n\n        response_headers = self._get_cors_headers_other()\n        self._get_checksum(response_headers)\n        return 200, response_headers, \"\"\n"
    },
    {
      "id": "getmoto_moto_10619_7",
      "input_code": "    def put_object_acl(self) -> TYPE_RESPONSE:\n        acl = self._acl_from_headers(self.headers)\n        if acl is None:\n            bucket = self.backend.get_bucket(self.bucket_name)\n            acl = bucket.acl\n        key_name = self.parse_key_name()\n        self.backend.put_object_acl(self.bucket_name, key_name, acl)\n\n        response_headers = self._get_cors_headers_other()\n        self._get_checksum(response_headers)\n        return 200, response_headers, \"\"\n"
    },
    {
      "id": "getmoto_moto_10619_5",
      "input_code": "    def copy_object(self) -> TYPE_RESPONSE:\n        copy_source = self.headers.get(\"x-amz-copy-source\")\n        if isinstance(copy_source, bytes):\n            copy_source = copy_source.decode(\"utf-8\")\n        copy_source_parsed = urlparse(copy_source)\n        src_bucket, src_key = unquote(copy_source_parsed.path).lstrip(\"/\").split(\"/\", 1)\n        src_version_id = parse_qs(copy_source_parsed.query).get(\"versionId\", [None])[0]\n\n        key_to_copy = self.backend.get_object(\n            src_bucket, src_key, version_id=src_version_id\n        )\n        key_name = self.parse_key_name()\n\n        bucket = self.backend.get_bucket(self.bucket_name)\n        lock_enabled = bucket.object_lock_enabled\n\n        encryption = self.headers.get(\"x-amz-server-side-encryption\")\n        kms_key_id = self.headers.get(\"x-amz-server-side-encryption-aws-kms-key-id\")\n        bucket_key_enabled = self.headers.get(\n            \"x-amz-server-side-encryption-bucket-key-enabled\"\n        )\n        if bucket_key_enabled is not None:\n            bucket_key_enabled = str(bucket_key_enabled).lower()\n\n        legal_hold, lock_mode, lock_until = self._get_lock_details(bucket, lock_enabled)\n\n        if key_to_copy is not None:\n            if \"x-amz-copy-source-if-none-match\" in self.headers:\n                requested_etag = self.headers[\"x-amz-copy-source-if-none-match\"]\n                if requested_etag in [key_to_copy.etag, key_to_copy.etag[1:-1]]:\n                    raise PreconditionFailed(\n                        failed_condition=\"x-amz-copy-source-If-None-Match\"\n                    )\n\n            if key_to_copy.storage_class in ARCHIVE_STORAGE_CLASSES:\n                if key_to_copy.response_dict.get(\n                    \"x-amz-restore\"\n                ) is None or 'ongoing-request=\"true\"' in key_to_copy.response_dict.get(                    \"x-amz-restore\"\n                ):\n                    raise ObjectNotInActiveTierError(key_to_copy)\n\n            website_redirect_location = self.headers.get(\n                \"x-amz-website-redirect-location\"\n            )\n\n            mdirective = self.headers.get(\"x-amz-metadata-directive\")\n            metadata = metadata_from_headers(self.headers)\n            self.backend.copy_object(\n                key_to_copy,\n                self.bucket_name,\n                key_name,\n                storage=self.headers.get(\"x-amz-storage-class\"),\n                kms_key_id=kms_key_id,\n                encryption=encryption,\n                bucket_key_enabled=bucket_key_enabled,\n                mdirective=mdirective,\n                metadata=metadata,\n                website_redirect_location=website_redirect_location,\n                lock_mode=lock_mode,\n                lock_legal_status=legal_hold,\n                lock_until=lock_until,\n                provided_version_id=src_version_id,\n            )\n        else:\n            if src_version_id:\n                raise MissingVersion()\n            raise MissingKey(key=src_key)\n\n        new_key: FakeKey = self.backend.get_object(self.bucket_name, key_name)\n\n        acl = self._acl_from_headers(self.headers)\n        if acl is None:\n            acl = bucket.acl\n        if acl is not None:\n            new_key.set_acl(acl)\n\n        response_headers = self._get_cors_headers_other()\n        tdirective = self.headers.get(\"x-amz-tagging-directive\")\n        if tdirective == \"REPLACE\":\n            tagging = self._tagging_from_headers(self.headers)\n            self.backend.put_object_tagging(new_key, tagging)\n        if key_to_copy.version_id != \"null\":\n            response_headers[\"x-amz-copy-source-version-id\"] = key_to_copy.version_id\n\n        checksum_algorithm = self.headers.get(\"x-amz-checksum-algorithm\")\n        if checksum_algorithm:\n            checksum_value = compute_checksum(\n                new_key.value, algorithm=checksum_algorithm\n            ).decode(\"utf-8\")\n            response_headers.update(\n                {\"Checksum\": {f\"Checksum{checksum_algorithm}\": checksum_value}}\n            )\n            new_key.checksum_algorithm = checksum_algorithm\n            new_key.checksum_value = checksum_value\n\n        template = self.response_template(S3_OBJECT_COPY_RESPONSE)\n        response_headers.update(new_key.response_dict)\n        response = template.render(key=new_key)\n        response_headers[\"content-length\"] = str(len(response))\n        return 200, response_headers, response\n"
    },
    {
      "id": "getmoto_moto_10619_10",
      "input_code": "    def delete_object(self) -> TYPE_RESPONSE:\n        bypass = self.headers.get(\"X-Amz-Bypass-Governance-Retention\")\n        key_name = self.parse_key_name()\n        version_id = self._get_param(\"versionId\")\n        _, response_meta = self.backend.delete_object(\n            self.bucket_name, key_name, version_id=version_id, bypass=bypass\n        )\n        response_headers = {}\n        for k in response_meta:\n            response_headers[f\"x-amz-{k}\"] = response_meta[k]\n        return 204, response_headers, \"\"\n"
    },
    {
      "id": "getmoto_moto_10619_4",
      "input_code": "    def put_object(self) -> TYPE_RESPONSE:\n        key_name = self.parse_key_name()\n        response_headers = self._get_cors_headers_other()\n\n        storage_class = self.headers.get(\"x-amz-storage-class\", \"STANDARD\")\n        encryption = self.headers.get(\"x-amz-server-side-encryption\")\n        kms_key_id = self.headers.get(\"x-amz-server-side-encryption-aws-kms-key-id\")\n        if_none_match = self.headers.get(\"If-None-Match\")\n        bucket_key_enabled = self.headers.get(\n            \"x-amz-server-side-encryption-bucket-key-enabled\"\n        )\n        if bucket_key_enabled is not None:\n            bucket_key_enabled = str(bucket_key_enabled).lower()\n\n        if (\n            if_none_match == \"*\"\n            and self.backend.get_object(self.bucket_name, key_name) is not None\n        ):\n            raise PreconditionFailed(\"If-None-Match\")\n\n        checksum_algorithm, checksum_value = self._get_checksum(response_headers)\n\n        bucket = self.backend.get_bucket(self.bucket_name)\n        lock_enabled = bucket.object_lock_enabled\n\n        legal_hold, lock_mode, lock_until = self._get_lock_details(bucket, lock_enabled)\n\n        acl = self._acl_from_headers(self.headers)\n        if acl is None:\n            acl = bucket.acl\n        tagging = self._tagging_from_headers(self.headers)\n\n        new_key = self.backend.put_object(\n            self.bucket_name,\n            key_name,\n            self.body or b\"\",\n            storage=storage_class,\n            encryption=encryption,\n            kms_key_id=kms_key_id,\n            bucket_key_enabled=bucket_key_enabled,\n            lock_mode=lock_mode,\n            lock_legal_status=legal_hold,\n            lock_until=lock_until,\n            checksum_value=checksum_value,\n        )\n        metadata = metadata_from_headers(self.headers)\n        metadata.update(metadata_from_headers(self.querystring))\n        new_key.set_metadata(metadata)\n        new_key.set_acl(acl)\n        new_key.website_redirect_location = self.headers.get(\n            \"x-amz-website-redirect-location\"\n        )\n        if checksum_algorithm:\n            new_key.checksum_algorithm = checksum_algorithm\n        self.backend.put_object_tagging(new_key, tagging)\n        response_headers.update(new_key.response_dict)\n        response_headers.pop(\"content-length\", None)\n        return 200, response_headers, \"\"\n"
    },
    {
      "id": "getmoto_moto_10619_1",
      "input_code": "    def _key_response(self, request: Any, full_url: str) -> TYPE_RESPONSE:\n        parsed_url = urlparse(full_url)\n        query = parse_qs(parsed_url.query, keep_blank_values=True)\n        method = request.method\n\n        key_name = self.parse_key_name()\n        bucket_name = self.parse_bucket_name_from_url(request, full_url)\n\n        authorized_request = \"Authorization\" in request.headers\n        if hasattr(request, \"url\"):\n            signed_url = \"Signature=\" in request.url\n        elif hasattr(request, \"requestline\"):\n            signed_url = \"Signature=\" in request.path\n        try:\n            key = self.backend.get_object(bucket_name, key_name)\n            bucket = self.backend.get_bucket(bucket_name)\n        except S3ClientError:\n            key = bucket = None\n\n        if bucket:\n            resource = f\"arn:{bucket.partition}:s3:::{bucket_name}/{key_name}\"\n\n\n            from moto.iam.access_control import PermissionResult\n\n            action = f\"s3:{method.upper()[0]}{method.lower()[1:]}Object\"\n            bucket_permissions = bucket.get_permission(action, resource)\n            if bucket_permissions == PermissionResult.DENIED:\n                return 403, {}, \"\"\n\n            if key:\n                if not authorized_request and not signed_url:\n                    if bucket_permissions != PermissionResult.PERMITTED and (\n                        key.acl and not key.acl.public_read\n                    ):\n                        return 403, {}, \"\"\n        if not key and signed_url and not authorized_request:\n            if self._invalid_headers(request.url, dict(request.headers)):\n                return 403, {}, S3_INVALID_PRESIGNED_PARAMETERS\n\n        body = self.body or b\"\"\n\n        if method == \"GET\":\n            return self._key_response_get(query, key_name)\n        elif method == \"PUT\":\n            return self._key_response_put(query, key_name)\n        elif method == \"HEAD\":\n            return self.head_object(\n                bucket_name, query, key_name, headers=request.headers\n            )\n        elif method == \"DELETE\":\n            return self._key_response_delete(bucket_name, query, key_name)\n        elif method == \"POST\":\n            return self._key_response_post(request, body, bucket_name, query, key_name)\n        elif method == \"OPTIONS\":\n            return self._response_options(request.headers, bucket_name)\n        else:\n            raise NotImplementedError(\n                f\"Method {method} has not been implemented in the S3 backend yet\"\n            )\n"
    },
    {
      "id": "getmoto_moto_10619_11",
      "input_code": "    def delete_object_tagging(self) -> TYPE_RESPONSE:\n        key_name = self.parse_key_name()\n        version_id = self._get_param(\"versionId\")\n        self.backend.delete_object_tagging(\n            self.bucket_name, key_name, version_id=version_id\n        )\n        template = self.response_template(S3_DELETE_KEY_TAGGING_RESPONSE)\n        return 204, {}, template.render(version_id=version_id)\n"
    },
    {
      "id": "getmoto_moto_10619_8",
      "input_code": "    def put_object_legal_hold(self) -> TYPE_RESPONSE:\n        version_id = self._get_param(\"versionId\")\n        bucket = self.backend.get_bucket(self.bucket_name)\n        lock_enabled = bucket.object_lock_enabled\n        key_name = self.parse_key_name()\n\n        if not lock_enabled:\n            raise LockNotEnabled\n        legal_hold_status = self._legal_hold_status_from_xml(self.body)\n        self.backend.put_object_legal_hold(\n            self.bucket_name, key_name, version_id, legal_hold_status\n        )\n\n        response_headers = self._get_cors_headers_other()\n        self._get_checksum(response_headers)\n        return 200, response_headers, \"\"\n"
    },
    {
      "id": "getmoto_moto_10619_2",
      "input_code": "    def list_parts(self) -> TYPE_RESPONSE:\n        response_headers = self._get_cors_headers_other()\n\n        upload_id = self._get_param(\"uploadId\")\n\n        part_number_marker = self._get_int_param(\"part-number-marker\", 0)\n        if part_number_marker > 2147483647:\n            raise NotAnIntegerException(\n                name=\"part-number-marker\", value=part_number_marker\n            )\n        if not (0 <= part_number_marker <= 2147483647):\n            raise InvalidMaxPartArgument(\"part-number-marker\", 0, 2147483647)\n\n        max_parts = self._get_int_param(\"max-parts\", 1000)\n        if max_parts > 2147483647:\n            raise NotAnIntegerException(name=\"max-parts\", value=max_parts)\n        if not (0 <= max_parts <= 2147483647):\n            raise InvalidMaxPartArgument(\"max-parts\", 0, 2147483647)\n\n        parts = self.backend.list_parts(\n            self.bucket_name,\n            upload_id,\n            part_number_marker=part_number_marker,\n            max_parts=max_parts,\n        )\n        next_part_number_marker = parts[-1].name if parts else 0\n        is_truncated = len(parts) != 0 and self.backend.is_truncated(\n            self.bucket_name,\n            upload_id,\n            next_part_number_marker,        )\n\n        key_name = self.parse_key_name()\n        template = self.response_template(S3_MULTIPART_LIST_RESPONSE)\n        return (\n            200,\n            response_headers,\n            template.render(\n                bucket_name=self.bucket_name,\n                key_name=key_name,\n                upload_id=upload_id,\n                is_truncated=str(is_truncated).lower(),\n                max_parts=max_parts,\n                next_part_number_marker=next_part_number_marker,\n                parts=parts,\n                part_number_marker=part_number_marker,\n            ),\n        )\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport urllib.parse\n\n<testcase_1>\npth = \"/example/path/to/object\"\n\n<testcase_2>\npth = \"example/path/to/object\"\n\n<testcase_3>\npth = \"/another/example/with/slash\"\n\n<testcase_4>\npth = \"no/leading/slash\"\n\n<testcase_5>\npth = \"/yet/another/example\""
  ],
  "gpt_output": "<needimport>\nimport urllib.parse\n\n<testcase_1>\npth = \"/example/path/to/object\"\n\n<testcase_2>\npth = \"example/path/to/object\"\n\n<testcase_3>\npth = \"/another/example/with/slash\"\n\n<testcase_4>\npth = \"no/leading/slash\"\n\n<testcase_5>\npth = \"/yet/another/example\"",
  "needimport": "import urllib.parse\n\n",
  "test_results": {
    "ans1": "example/path/to/object",
    "ans2": "example/path/to/object",
    "ans3": "another/example/with/slash",
    "ans4": "no/leading/slash",
    "ans5": "yet/another/example"
  }
}