{
  "input_header": "def debug_error_message(msg):",
  "input_docstring": "Returns the error message `msg` if config.DEBUG is True\notherwise returns `None` which will cause Werkzeug to provide\na generic error message\n\n:param msg: The error message to return if config.DEBUG is True\n\n.. versionadded: 0.0.9",
  "output_code": "def debug_error_message(msg):\n    \n    if getattr(config, \"DEBUG\", False):\n        return msg\n    return None",
  "input_contexts": [
    {
      "id": "pyeve_eve_241_17",
      "input_code": "def synthesize_versioned_document(document, delta, resource_def):\n    \n    versioned_doc = {}\n    id_field = versioned_id_field(resource_def)\n\n    if id_field not in delta:\n        abort(\n            400,\n            description=debug_error_message(\n                \"You must include %s in any projection with a version query.\" % id_field\n            ),\n        )\n    delta[resource_def[\"id_field\"]] = delta[id_field]\n    del delta[id_field]\n\n    fields = versioned_fields(resource_def)\n    for field in document:\n        if field not in fields:\n            versioned_doc[field] = document[field]\n\n    versioned_doc.update(delta)\n\n    return versioned_doc\n"
    },
    {
      "id": "pyeve_eve_241_12",
      "input_code": "def patch_internal(\n    resource,\n    payload=None,\n    concurrency_check=False,\n    skip_validation=False,\n    mongo_options=None,\n    **lookup\n):\n    \n    if payload is None:\n        payload = payload_()\n\n    original = get_document(\n        resource, concurrency_check, mongo_options=mongo_options, **lookup\n    )\n    if not original:\n        abort(404)\n\n    resource_def = app.config[\"DOMAIN\"][resource]\n    schema = resource_def[\"schema\"]\n    normalize_document = resource_def.get(\"normalize_on_patch\")\n    validator = app.validator(\n        schema, resource=resource, allow_unknown=resource_def[\"allow_unknown\"]\n    )\n\n    object_id = original[resource_def[\"id_field\"]]\n    last_modified = None\n    etag = None\n\n    issues = {}\n    response = {}\n\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n\n    try:\n        updates = parse(payload, resource)\n        if skip_validation:\n            validation = True\n        else:\n            validation = validator.validate_update(\n                updates, object_id, original, normalize_document\n            )\n            updates = validator.document\n\n        if validation:\n\n            late_versioning_catch(original, resource)\n\n            store_media_files(updates, resource, original)\n            resolve_document_version(updates, resource, \"PATCH\", original)\n\n            updates[config.LAST_UPDATED] = utcnow()\n\n            if resource_def[\"soft_delete\"] is True:\n                updates[config.DELETED] = False\n\n            updated = deepcopy(original)\n\n            getattr(app, \"on_update\")(resource, updates, original)\n            getattr(app, \"on_update_%s\" % resource)(updates, original)\n\n            if resource_def[\"merge_nested_documents\"]:\n                updates = resolve_nested_documents(updates, updated)\n\n            updated.update(updates)\n\n            if config.IF_MATCH:\n                resolve_document_etag(updated, resource)\n                updates[config.ETAG] = updated[config.ETAG]\n            try:\n                app.data.update(resource, object_id, updates, original)\n            except app.data.OriginalChangedError:\n                if concurrency_check:\n                    abort(412, description=\"Client and server etags don't match\")\n\n            oplog_push(resource, updates, \"PATCH\", object_id)\n\n            insert_versioning_documents(resource, updated)\n\n            getattr(app, \"on_updated\")(resource, updates, original)\n            getattr(app, \"on_updated_%s\" % resource)(updates, original)\n\n            updated.update(updates)\n\n            build_response_document(updated, resource, embedded_fields, updated)\n            response = updated\n            if config.IF_MATCH:\n                etag = response[config.ETAG]\n        else:\n            issues = validator.errors\n    except DocumentError as e:\n        issues[\"validator exception\"] = str(e)\n    except exceptions.HTTPException as e:\n        raise e\n    except Exception as e:\n        app.logger.exception(e)\n        abort(400, description=debug_error_message(\"An exception occurred: %s\" % e))\n\n    if len(issues):\n        response[config.ISSUES] = issues\n        response[config.STATUS] = config.STATUS_ERR\n        status = config.VALIDATION_ERROR_STATUS\n    else:\n        response[config.STATUS] = config.STATUS_OK\n        status = 200\n\n    response = marshal_write_response(response, resource)\n\n    return response, last_modified, etag, status\n"
    },
    {
      "id": "pyeve_eve_241_5",
      "input_code": "    def remove(self, resource, lookup):\n        \n        lookup = self._mongotize(lookup, resource)\n        datasource, filter_, _, _ = self._datasource_ex(resource, lookup)\n\n        coll = self.get_collection_with_write_concern(datasource, resource)\n        try:\n            coll.delete_many(filter_)\n        except pymongo.errors.OperationFailure as e:\n            self.app.logger.exception(e)\n            abort(\n                500,\n                description=debug_error_message(\n                    \"pymongo.errors.OperationFailure: %s\" % e\n                ),\n            )\n"
    },
    {
      "id": "pyeve_eve_241_2",
      "input_code": "    def find(self, resource, req, sub_resource_lookup, perform_count=True):\n        \n        args = {}\n\n        if req and req.max_results:\n            args[\"limit\"] = req.max_results\n\n        if req and req.page > 1:\n            args[\"skip\"] = (req.page - 1) * req.max_results\n\n\n\n        client_sort = self._convert_sort_request_to_dict(req)\n        spec = self._convert_where_request_to_dict(resource, req)\n\n        bad_filter = validate_filters(spec, resource)\n        if bad_filter:\n            abort(400, bad_filter)\n\n        if sub_resource_lookup:\n            spec = self.combine_queries(spec, sub_resource_lookup)\n\n        if (\n            config.DOMAIN[resource][\"soft_delete\"]\n            and not (req and req.show_deleted)\n            and not self.query_contains_field(spec, config.DELETED)\n        ):\n            spec = self.combine_queries(spec, {config.DELETED: {\"$ne\": True}})\n\n        spec = self._mongotize(spec, resource)\n\n        client_projection = self._client_projection(req)\n\n        datasource, spec, projection, sort = self._datasource_ex(\n            resource, spec, client_projection, client_sort\n        )\n\n        if req and req.if_modified_since:\n            spec[config.LAST_UPDATED] = {\"$gt\": req.if_modified_since}\n\n        if len(spec) > 0:\n            args[\"filter\"] = spec\n\n        if sort is not None:\n            args[\"sort\"] = sort\n\n        if projection:\n            args[\"projection\"] = projection\n\n        target = self.pymongo(resource).db[datasource]\n        try:\n            result = target.find(**args)\n        except TypeError as e:\n            self.app.logger.exception(e)\n            abort(400, description=debug_error_message(str(e)))\n\n        if perform_count:\n            try:\n                count = target.count_documents(spec)\n            except Exception:\n\n\n                count = target.count()\n        else:\n            count = None\n\n        return result, count\n"
    },
    {
      "id": "pyeve_eve_241_7",
      "input_code": "    def _sanitize(self, resource, spec):\n        \n\n        def sanitize_keys(spec):\n            ops = set([op for op in spec.keys() if op[0] == \"$\"])\n            known = Mongo.operators | set(\n                config.DOMAIN[resource][\"mongo_query_whitelist\"]\n            )\n\n            unknown = ops - known\n            if unknown:\n                abort(\n                    400,\n                    description=debug_error_message(\n                        \"Query contains unknown or unsupported operators: %s\"\n                        % \", \".join(unknown)\n                    ),\n                )\n\n            if set(spec.keys()) & set(config.MONGO_QUERY_BLACKLIST):\n                abort(\n                    400,\n                    description=debug_error_message(\n                        \"Query contains operators banned in MONGO_QUERY_BLACKLIST\"\n                    ),\n                )\n\n        if isinstance(spec, dict):\n            sanitize_keys(spec)\n            for value in spec.values():\n                self._sanitize(resource, value)\n        if isinstance(spec, list):\n            for value in spec:\n                self._sanitize(resource, value)\n\n        return spec\n"
    },
    {
      "id": "pyeve_eve_241_13",
      "input_code": "def post_internal(resource, payl=None, skip_validation=False):\n    \n\n    date_utc = utcnow()\n    resource_def = app.config[\"DOMAIN\"][resource]\n    schema = resource_def[\"schema\"]\n    validator = (\n        None\n        if skip_validation\n        else app.validator(\n            schema, resource=resource, allow_unknown=resource_def[\"allow_unknown\"]\n        )\n    )\n\n    documents = []\n    results = []\n    failures = 0\n    id_field = resource_def[\"id_field\"]\n\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n\n    if payl is None:\n        payl = payload()\n\n    if isinstance(payl, dict):\n        payl = [payl]\n\n    if not payl:\n        abort(400, description=debug_error_message(\"Empty bulk insert\"))\n\n    if len(payl) > 1 and not config.DOMAIN[resource][\"bulk_enabled\"]:\n        abort(400, description=debug_error_message(\"Bulk insert not allowed\"))\n\n    for value in payl:\n        document = []\n        doc_issues = {}\n        try:\n            document = parse(value, resource)\n            resolve_sub_resource_path(document, resource)\n            if skip_validation:\n                validation = True\n            else:\n                validation = validator.validate(document)\n            if validation:\n                if validator:\n                    document = validator.document\n\n                document[config.LAST_UPDATED] = document[config.DATE_CREATED] = date_utc\n\n                if config.DOMAIN[resource][\"soft_delete\"] is True:\n                    document[config.DELETED] = False\n\n                resolve_user_restricted_access(document, resource)\n                store_media_files(document, resource)\n                resolve_document_version(document, resource, \"POST\")\n            else:\n                doc_issues = validator.errors\n        except DocumentError as e:\n            doc_issues[\"validation exception\"] = str(e)\n        except Exception as e:\n            app.logger.exception(e)\n            doc_issues[\"exception\"] = str(e)\n\n        if doc_issues:\n            document = {config.STATUS: config.STATUS_ERR, config.ISSUES: doc_issues}\n            failures += 1\n\n        documents.append(document)\n\n    if failures:\n        for document in documents:\n            if (\n                config.STATUS in document\n                and document[config.STATUS] == config.STATUS_ERR\n            ):\n                results.append(document)\n            else:\n                results.append({config.STATUS: config.STATUS_OK})\n\n        return_code = config.VALIDATION_ERROR_STATUS\n    else:\n        getattr(app, \"on_insert\")(resource, documents)\n        getattr(app, \"on_insert_%s\" % resource)(documents)\n\n        resolve_document_etag(documents, resource)\n\n        ids = app.data.insert(resource, documents)\n\n        oplog_push(resource, documents, \"POST\")\n\n        for document in documents:\n            id_ = document.get(id_field, ids.pop(0))\n            document[id_field] = id_\n\n            result = document\n            build_response_document(result, resource, embedded_fields, document)\n\n            result[config.STATUS] = config.STATUS_OK\n\n            result = marshal_write_response(result, resource)\n            results.append(result)\n\n        insert_versioning_documents(resource, documents)\n\n        getattr(app, \"on_inserted\")(resource, documents)\n        getattr(app, \"on_inserted_%s\" % resource)(documents)\n\n        return_code = 201\n\n    if len(results) == 1:\n        response = results.pop(0)\n    else:\n        response = {\n            config.STATUS: config.STATUS_ERR if failures else config.STATUS_OK,\n            config.ITEMS: results,\n        }\n\n    if failures:\n        response[config.ERROR] = {\n            \"code\": return_code,\n            \"message\": \"Insertion failure: %d document(s) contain(s) error(s)\"\n            % failures,\n        }\n\n    location_header = (\n        None\n        if return_code != 201 or not documents\n        else [(\"Location\", \"%s/%s\" % (resource_link(), documents[0][id_field]))]\n    )\n\n    return response, None, None, return_code, location_header\n"
    },
    {
      "id": "pyeve_eve_241_16",
      "input_code": "def resolve_document_version(document, resource, method, latest_doc=None):\n    \n    resource_def = app.config[\"DOMAIN\"][resource]\n    version = app.config[\"VERSION\"]\n    latest_version = app.config[\"LATEST_VERSION\"]\n\n    if resource_def[\"versioning\"] is True:\n        if method == \"GET\" and latest_doc is None:\n            if version not in document:\n                document[version] = 1\n            document[latest_version] = document[version]\n\n        if method == \"GET\" and latest_doc is not None:\n            if version not in latest_doc:\n                document[version] = 1\n                document[latest_version] = document[version]\n            else:\n                document[latest_version] = latest_doc[version]\n                if version not in document:\n                    document[version] = 1\n\n        if method == \"POST\":\n            document[version] = 1\n\n        if (\n            method == \"PUT\"\n            or method == \"PATCH\"\n            or (method == \"DELETE\" and resource_def[\"soft_delete\"] is True)\n        ):\n            if not latest_doc:\n                abort(\n                    500,\n                    description=debug_error_message(\"I need the latest document here!\"),\n                )\n            if version in latest_doc:\n                document[version] = latest_doc[version] + 1\n            else:\n                document[version] = 1\n"
    },
    {
      "id": "pyeve_eve_241_15",
      "input_code": "def _best_mime():\n    \n    supported = []\n    renders = {}\n    for renderer_cls in app.config.get(\"RENDERERS\"):\n        renderer = import_from_string(renderer_cls)\n        for mime_type in renderer.mime:\n            supported.append(mime_type)\n            renders[mime_type] = renderer\n\n    if len(supported) == 0:\n        abort(\n            500,\n            description=debug_error_message(\n                \"Configuration error: no supported mime types\"\n            ),\n        )\n\n    best_match = request.accept_mimetypes.best_match(supported) or supported[0]\n    return best_match, renders[best_match]\n"
    },
    {
      "id": "pyeve_eve_241_19",
      "input_code": "    def test_debug_error_message(self):\n        with self.app.test_request_context():\n            self.app.config[\"DEBUG\"] = False\n            self.assertEqual(debug_error_message(\"An error message\"), None)\n            self.app.config[\"DEBUG\"] = True\n            self.assertEqual(\n                debug_error_message(\"An error message\"), \"An error message\"\n            )\n"
    },
    {
      "id": "pyeve_eve_241_3",
      "input_code": "    def insert(self, resource, doc_or_docs):\n        \n        datasource, _, _, _ = self._datasource_ex(resource)\n\n        coll = self.get_collection_with_write_concern(datasource, resource)\n\n        if isinstance(doc_or_docs, dict):\n            doc_or_docs = [doc_or_docs]\n\n        try:\n            return coll.insert_many(doc_or_docs, ordered=True).inserted_ids\n        except pymongo.errors.BulkWriteError as e:\n            self.app.logger.exception(e)\n\n\n            for error in e.details[\"writeErrors\"]:\n                if error[\"code\"] == 11000:\n                    abort(\n                        409,\n                        description=debug_error_message(\n                            \"Duplicate key error at index: %s, message: %s\"\n                            % (error[\"index\"], error[\"errmsg\"])\n                        ),\n                    )\n\n            abort(\n                500,\n                description=debug_error_message(\n                    \"pymongo.errors.BulkWriteError: %s\" % e\n                ),\n            )\n"
    },
    {
      "id": "pyeve_eve_241_11",
      "input_code": "def resolve_one_media(file_id, resource):\n    \n    _file = app.media.get(file_id, resource)\n\n    if _file:\n        if config.RETURN_MEDIA_AS_BASE64_STRING:\n            ret_file = base64.b64encode(_file.read())\n        elif config.RETURN_MEDIA_AS_URL:\n            prefix = (\n                config.MEDIA_BASE_URL\n                if config.MEDIA_BASE_URL is not None\n                else app.api_prefix\n            )\n            ret_file = \"%s/%s/%s\" % (prefix, config.MEDIA_ENDPOINT, file_id)\n        else:\n            ret_file = None\n\n        if config.EXTENDED_MEDIA_INFO:\n            ret = {\"file\": ret_file}\n\n            for attribute in config.EXTENDED_MEDIA_INFO:\n                if hasattr(_file, attribute):\n                    ret.update({attribute: getattr(_file, attribute)})\n                else:\n                    abort(\n                        500,\n                        description=debug_error_message(\n                            \"Invalid extended media attribute requested\"\n                        ),\n                    )\n\n            return ret\n        return ret_file\n    return None\n"
    },
    {
      "id": "pyeve_eve_241_9",
      "input_code": "    def _convert_where_request_to_dict(self, resource, req):\n        \n        query = {}\n        if req and req.where:\n            try:\n                query = self._sanitize(resource, json.loads(req.where))\n            except HTTPException:\n                raise\n            except Exception:\n                try:\n                    query = parse(req.where)\n                except ParseError:\n                    abort(\n                        400,\n                        description=debug_error_message(\n                            \"Unable to parse `where` clause\"\n                        ),\n                    )\n        return query\n"
    },
    {
      "id": "pyeve_eve_241_10",
      "input_code": "def embedded_document(references, data_relation, field_name):\n    \n    embedded_docs = []\n\n    output_is_list = True\n\n    if not isinstance(references, list):\n        output_is_list = False\n        references = [references]\n\n    if \"version\" in data_relation and data_relation[\"version\"] is True:\n        for reference in references:\n            embedded_doc = get_data_version_relation_document(data_relation, reference)\n\n            latest_embedded_doc = get_data_version_relation_document(\n                data_relation, reference, latest=True\n            )\n\n            if embedded_doc is None or latest_embedded_doc is None:\n                abort(\n                    404,\n                    description=debug_error_message(\n                        \"Unable to locate embedded documents for '%s'\" % field_name\n                    ),\n                )\n\n            build_response_document(\n                embedded_doc, data_relation[\"resource\"], [], latest_embedded_doc\n            )\n            embedded_docs.append(embedded_doc)\n    else:\n        (\n            id_value_to_sort,\n            list_of_id_field_name,\n            subresources_query,\n        ) = generate_query_and_sorting_criteria(data_relation, references)\n        for subresource in subresources_query:\n            result, _ = app.data.find(\n                subresource, None, subresources_query[subresource]\n            )\n            list_embedded_doc = list(result)\n\n            if not list_embedded_doc:\n                embedded_docs.extend(\n                    [None] * len(subresources_query[subresource][\"$or\"])\n                )\n            else:\n                for embedded_doc in list_embedded_doc:\n                    resolve_media_files(embedded_doc, subresource)\n                embedded_docs.extend(list_embedded_doc)\n\n        if embedded_docs:\n            embedded_docs = sort_db_response(\n                embedded_docs, id_value_to_sort, list_of_id_field_name\n            )\n\n    if output_is_list:\n        return embedded_docs\n    if embedded_docs:\n        return embedded_docs[0]\n    return None\n"
    },
    {
      "id": "pyeve_eve_241_18",
      "input_code": "def get_old_document(resource, req, lookup, document, version):\n    \n    if version != \"all\" and version != \"diffs\" and version is not None:\n        try:\n            version = int(version)\n            assert version > 0\n        except (ValueError, BadRequestKeyError, AssertionError):\n            abort(\n                400,\n                description=debug_error_message(\n                    \"Document version number should be an int greater than 0\"\n                ),\n            )\n\n        resource_def = config.DOMAIN[resource]\n        if versioned_id_field(resource_def) not in lookup:\n            lookup[versioned_id_field(resource_def)] = lookup[resource_def[\"id_field\"]]\n            del lookup[resource_def[\"id_field\"]]\n        lookup[config.VERSION] = version\n\n        delta = app.data.find_one(resource + config.VERSIONS, req, **lookup)\n        if not delta:\n            abort(404)\n        old_document = synthesize_versioned_document(document, delta, resource_def)\n    else:\n        old_document = document.copy()\n\n    return old_document\n"
    },
    {
      "id": "pyeve_eve_241_1",
      "input_code": "    def _client_projection(self, req):\n        \n        client_projection = {}\n        if req and req.projection:\n            try:\n                client_projection = json.loads(req.projection)\n                if not isinstance(client_projection, dict):\n                    raise Exception(\"The projection parameter has to be a \" \"dict\")\n            except Exception:\n                abort(\n                    400,\n                    description=debug_error_message(\n                        \"Unable to parse `projection` clause\"\n                    ),\n                )\n        return client_projection\n"
    },
    {
      "id": "pyeve_eve_241_4",
      "input_code": "    def _change_request(self, resource, id_, changes, original, replace=False):\n        \n        id_field = config.DOMAIN[resource][\"id_field\"]\n        query = {id_field: id_}\n        if config.ETAG in original:\n            query[config.ETAG] = original[config.ETAG]\n\n        datasource, filter_, _, _ = self._datasource_ex(resource, query)\n\n        coll = self.get_collection_with_write_concern(datasource, resource)\n        try:\n            result = (\n                coll.replace_one(filter_, changes)\n                if replace\n                else coll.update_one(filter_, changes)\n            )\n            if (\n                config.ETAG in original\n                and result\n                and result.acknowledged\n                and result.modified_count == 0\n            ):\n                raise self.OriginalChangedError()\n        except pymongo.errors.DuplicateKeyError as e:\n            abort(\n                400,\n                description=debug_error_message(\n                    \"pymongo.errors.DuplicateKeyError: %s\" % e\n                ),\n            )\n        except (pymongo.errors.WriteError, pymongo.errors.OperationFailure) as e:\n            server_version = self.driver.db.client.server_info()[\"version\"][:3]\n            if (server_version == \"2.4\" and e.code in (13596, 10148)) or e.code in (\n                66,\n                16837,\n            ):\n                self.app.logger.warning(e)\n                description = (\n                    debug_error_message(\"pymongo.errors.OperationFailure: %s\" % e)\n                    or \"Attempt to update an immutable field. Usually happens \"\n                    \"when PATCH or PUT include a '%s' field, \"\n                    \"which is immutable (PUT can include it as long as \"\n                    \"it is unchanged).\" % id_field\n                )\n\n                abort(400, description=description)\n            else:\n                self.app.logger.exception(e)\n                abort(\n                    500,\n                    description=debug_error_message(\n                        \"pymongo.errors.OperationFailure: %s\" % e\n                    ),\n                )\n"
    },
    {
      "id": "pyeve_eve_241_14",
      "input_code": "def put_internal(\n    resource, payload=None, concurrency_check=False, skip_validation=False, **lookup\n):\n    \n    resource_def = app.config[\"DOMAIN\"][resource]\n    schema = resource_def[\"schema\"]\n    validator = app.validator(\n        schema, resource=resource, allow_unknown=resource_def[\"allow_unknown\"]\n    )\n\n    if payload is None:\n        payload = payload_()\n\n    original = get_document(\n        resource,\n        concurrency_check,\n        check_auth_value=False,\n        force_auth_field_projection=True,\n        **lookup\n    )\n    if not original:\n        if config.UPSERT_ON_PUT:\n            id = lookup[resource_def[\"id_field\"]]\n            if schema[resource_def[\"id_field\"]].get(\"type\", \"\") == \"objectid\":\n                id = str(id)\n            payload[resource_def[\"id_field\"]] = id\n            return post_internal(resource, payl=payload)\n        abort(404)\n\n    auth_field, request_auth_value = auth_field_and_value(resource)\n    if auth_field and original.get(auth_field) != request_auth_value:\n        abort(403)\n\n    last_modified = None\n    etag = None\n    issues = {}\n    object_id = original[resource_def[\"id_field\"]]\n\n    response = {}\n\n    if config.BANDWIDTH_SAVER is True:\n        embedded_fields = []\n    else:\n        req = parse_request(resource)\n        embedded_fields = resolve_embedded_fields(resource, req)\n\n    try:\n        document = parse(payload, resource)\n        resolve_sub_resource_path(document, resource)\n        if skip_validation:\n            validation = True\n        else:\n            validation = validator.validate_replace(document, object_id, original)\n            document = validator.document\n\n        if validation:\n            late_versioning_catch(original, resource)\n\n            last_modified = utcnow()\n            document[config.LAST_UPDATED] = last_modified\n            document[config.DATE_CREATED] = original[config.DATE_CREATED]\n            if resource_def[\"soft_delete\"] is True:\n                document[config.DELETED] = False\n\n            if resource_def[\"id_field\"] not in document:\n                document[resource_def[\"id_field\"]] = object_id\n\n            resolve_user_restricted_access(document, resource)\n            store_media_files(document, resource, original)\n            resolve_document_version(document, resource, \"PUT\", original)\n\n            getattr(app, \"on_replace\")(resource, document, original)\n            getattr(app, \"on_replace_%s\" % resource)(document, original)\n\n            resolve_document_etag(document, resource)\n\n            try:\n                app.data.replace(resource, object_id, document, original)\n            except app.data.OriginalChangedError:\n                if concurrency_check:\n                    abort(412, description=\"Client and server etags don't match\")\n\n            oplog_push(resource, document, \"PUT\")\n\n            insert_versioning_documents(resource, document)\n\n            getattr(app, \"on_replaced\")(resource, document, original)\n            getattr(app, \"on_replaced_%s\" % resource)(document, original)\n\n            build_response_document(document, resource, embedded_fields, document)\n            response = document\n            if config.IF_MATCH:\n                etag = response[config.ETAG]\n        else:\n            issues = validator.errors\n    except DocumentError as e:\n        issues[\"validator exception\"] = str(e)\n    except exceptions.HTTPException as e:\n        raise e\n    except Exception as e:\n        app.logger.exception(e)\n        abort(400, description=debug_error_message(\"An exception occurred: %s\" % e))\n\n    if issues:\n        response[config.ISSUES] = issues\n        response[config.STATUS] = config.STATUS_ERR\n        status = config.VALIDATION_ERROR_STATUS\n    else:\n        response[config.STATUS] = config.STATUS_OK\n        status = 200\n\n    response = marshal_write_response(response, resource)\n\n    return response, last_modified, etag, status\n"
    },
    {
      "id": "pyeve_eve_241_8",
      "input_code": "    def _convert_sort_request_to_dict(self, req):\n        \n        client_sort = {}\n        if req and req.sort:\n            try:\n                client_sort = ast.literal_eval(req.sort)\n            except ValueError:\n                sort = []\n                for sort_arg in [s.strip() for s in req.sort.split(\",\")]:\n                    if sort_arg[0] == \"-\":\n                        sort.append((sort_arg[1:], -1))\n                    else:\n                        sort.append((sort_arg, 1))\n                if len(sort) > 0:\n                    client_sort = sort\n            except Exception as e:\n                self.app.logger.exception(e)\n                abort(400, description=debug_error_message(str(e)))\n        return client_sort\n"
    },
    {
      "id": "pyeve_eve_241_6",
      "input_code": "    def is_empty(self, resource):\n        \n        datasource, filter_, _, _ = self.datasource(resource)\n        coll = self.pymongo(resource).db[datasource]\n        try:\n            if not filter_:\n                return coll.count_documents({}) == 0\n            try:\n                del filter_[config.LAST_UPDATED]\n            except Exception:\n                pass\n            return coll.count_documents(filter_) == 0\n        except pymongo.errors.OperationFailure as e:\n            self.app.logger.exception(e)\n            abort(\n                500,\n                description=debug_error_message(\n                    \"pymongo.errors.OperationFailure: %s\" % e\n                ),\n            )\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport config\n\n<testcase_1>\nmsg = \"Database connection failed\"\n\n<testcase_2>\nmsg = \"Invalid user input detected\"\n\n<testcase_3>\nmsg = \"File not found\"\n\n<testcase_4>\nmsg = \"Permission denied\"\n\n<testcase_5>\nmsg = \"Unexpected error occurred\""
  ],
  "gpt_output": "<needimport>\nimport config\n\n<testcase_1>\nmsg = \"Database connection failed\"\n\n<testcase_2>\nmsg = \"Invalid user input detected\"\n\n<testcase_3>\nmsg = \"File not found\"\n\n<testcase_4>\nmsg = \"Permission denied\"\n\n<testcase_5>\nmsg = \"Unexpected error occurred\"",
  "needimport": "import config\n\n",
  "test_results": {
    "ans1": "Database connection failed",
    "ans2": "Invalid user input detected",
    "ans3": "File not found",
    "ans4": "Permission denied",
    "ans5": "Unexpected error occurred"
  }
}