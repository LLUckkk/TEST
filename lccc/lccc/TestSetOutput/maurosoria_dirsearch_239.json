{
  "input_header": "def warning(self, message, do_save=True):",
  "input_docstring": null,
  "output_code": "    def warning(self, message, do_save=True):\n        message = set_color(message, fore=\"yellow\", style=\"bright\")\n        self.new_line(message, do_save=do_save)",
  "input_contexts": [
    {
      "id": "maurosoria_dirsearch_239_3",
      "input_code": "    def handle_pause(self) -> None:\n        interface.warning(\n            \"CTRL+C detected: Pausing threads, please wait...\", do_save=False\n        )\n        self.fuzzer.pause()\n\n        while True:\n            msg = \"[q]uit / [c]ontinue\"\n\n            if len(self.directories) > 1:\n                msg += \" / [n]ext\"\n\n            if len(options[\"urls\"]) > 1:\n                msg += \" / [s]kip target\"\n\n            interface.in_line(msg + \": \")\n\n            option = input()\n\n            if option.lower() == \"q\":\n                interface.in_line(\"[s]ave / [q]uit without saving: \")\n\n                option = input()\n\n                if option.lower() == \"s\":\n                    msg = f'Save to file [{options[\"session_file\"] or DEFAULT_SESSION_FILE}]: '\n\n                    interface.in_line(msg)\n\n                    session_file = (\n                        input() or options[\"session_file\"] or DEFAULT_SESSION_FILE\n                    )\n\n                    self._export(session_file)\n                    quitexc = QuitInterrupt(f\"Session saved to: {session_file}\")\n                    if options[\"async_mode\"]:\n                        self.pause_future.set_exception(quitexc)\n                        break\n                    else:\n                        raise quitexc\n                elif option.lower() == \"q\":\n                    quitexc = QuitInterrupt(\"Canceled by the user\")\n                    if options[\"async_mode\"]:\n                        self.pause_future.set_exception(quitexc)\n                        break\n                    else:\n                        raise quitexc\n\n            elif option.lower() == \"c\":\n                self.fuzzer.play()\n                break\n\n            elif option.lower() == \"n\" and len(self.directories) > 1:\n                self.fuzzer.quit()\n                break\n\n            elif option.lower() == \"s\" and len(options[\"urls\"]) > 1:\n                skipexc = SkipTargetInterrupt(\"Target skipped by the user\")\n                if options[\"async_mode\"]:\n                    self.pause_future.set_exception(skipexc)\n                    break\n                else:\n                    raise skipexc\n"
    },
    {
      "id": "maurosoria_dirsearch_239_2",
      "input_code": "    def start(self) -> None:\n        while self.directories:\n            try:\n                gc.collect()\n\n                current_directory = self.directories[0]\n\n                if not self.old_session:\n                    current_time = time.strftime(\"%H:%M:%S\")\n                    msg = f\"{NEW_LINE}[{current_time}] Scanning: {current_directory}\"\n\n                    interface.warning(msg)\n\n                self.fuzzer.set_base_path(current_directory)\n                if options[\"async_mode\"]:\n                    self.pause_future = self.loop.create_future()\n                    self.loop.run_until_complete(self._start_coroutines())\n                else:\n                    self.fuzzer.start()\n                    self.process()\n\n            except (KeyboardInterrupt, asyncio.CancelledError):\n                pass\n\n            finally:\n                self.dictionary.reset()\n                self.directories.pop(0)\n\n                self.jobs_processed += 1\n                self.old_session = False\n"
    },
    {
      "id": "maurosoria_dirsearch_239_1",
      "input_code": "    def run(self) -> None:\n        if options[\"async_mode\"]:\n            from lib.connection.requester import AsyncRequester as Requester\n            from lib.core.fuzzer import AsyncFuzzer as Fuzzer\n\n            try:\n                import uvloop\n                asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n            except ImportError:\n                pass\n        else:\n            from lib.connection.requester import Requester\n            from lib.core.fuzzer import Fuzzer\n\n        match_callbacks = (\n            self.match_callback, self.reporter.save, self.reset_consecutive_errors\n        )\n        not_found_callbacks = (\n            self.update_progress_bar, self.reset_consecutive_errors\n        )\n        error_callbacks = (self.raise_error, self.append_error_log)\n\n        self.requester = Requester()\n        if options[\"async_mode\"]:\n            self.loop = asyncio.new_event_loop()\n\n        signal.signal(signal.SIGINT, lambda *_: self.handle_pause())\n        signal.signal(signal.SIGTERM, lambda *_: self.handle_pause())\n\n        while options[\"urls\"]:\n            url = options[\"urls\"][0]\n            self.fuzzer = Fuzzer(\n                self.requester,\n                self.dictionary,\n                match_callbacks=match_callbacks,\n                not_found_callbacks=not_found_callbacks,\n                error_callbacks=error_callbacks,\n            )\n\n            try:\n                self.set_target(url)\n\n                if not self.directories:\n                    for subdir in options[\"subdirs\"]:\n                        self.add_directory(self.base_path + subdir)\n\n                if not self.old_session:\n                    interface.target(self.url)\n\n                self.reporter.prepare(self.url)\n                self.start()\n\n            except (\n                CannotConnectException,\n                FileExistsException,\n                InvalidURLException,\n                RequestException,\n                SkipTargetInterrupt,\n                KeyboardInterrupt,\n            ) as e:\n                self.directories.clear()\n                self.dictionary.reset()\n\n                if e.args:\n                    interface.error(str(e))\n\n            except QuitInterrupt as e:\n                self.reporter.finish()\n                interface.error(e.args[0])\n                exit(0)\n\n            finally:\n                options[\"urls\"].pop(0)\n\n        interface.warning(\"\\nTask Completed\")\n        self.reporter.finish()\n\n        if options[\"session_file\"]:\n            try:\n                os.remove(options[\"session_file\"])\n            except Exception:\n                interface.error(\"Failed to delete old session file, remove it to free some space\")\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport os\nimport time\nimport signal\nimport asyncio\nimport gc\n\n<testcase_1>\nself = interface\nmessage = \"This is a warning message.\"\ndo_save = True\n\n<testcase_2>\nself = interface\nmessage = \"Another warning message with save disabled.\"\ndo_save = False\n\n<testcase_3>\nself = interface\nmessage = \"Warning: Task is about to complete.\"\ndo_save = True\n\n<testcase_4>\nself = interface\nmessage = \"Warning: An error occurred while processing.\"\ndo_save = False\n\n<testcase_5>\nself = interface\nmessage = \"Warning: Pausing threads due to user interruption.\"\ndo_save = False"
  ],
  "gpt_output": "<needimport>\nimport os\nimport time\nimport signal\nimport asyncio\nimport gc\n\n<testcase_1>\nself = interface\nmessage = \"This is a warning message.\"\ndo_save = True\n\n<testcase_2>\nself = interface\nmessage = \"Another warning message with save disabled.\"\ndo_save = False\n\n<testcase_3>\nself = interface\nmessage = \"Warning: Task is about to complete.\"\ndo_save = True\n\n<testcase_4>\nself = interface\nmessage = \"Warning: An error occurred while processing.\"\ndo_save = False\n\n<testcase_5>\nself = interface\nmessage = \"Warning: Pausing threads due to user interruption.\"\ndo_save = False",
  "needimport": "import os\nimport time\nimport signal\nimport asyncio\nimport gc\n\n",
  "test_results": {
    "ans1": "[bright yellow] This is a warning message.",
    "ans2": "[bright yellow] Another warning message with save disabled.",
    "ans3": "[bright yellow] Warning: Task is about to complete.",
    "ans4": "[bright yellow] Warning: An error occurred while processing.",
    "ans5": "[bright yellow] Warning: Pausing threads due to user interruption."
  }
}