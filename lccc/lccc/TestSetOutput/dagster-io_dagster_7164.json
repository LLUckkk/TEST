{
  "input_header": "def validate_expected_params( params: Sequence[Parameter], expected_params: Sequence[str] ) -> Optional[str]:",
  "input_docstring": "Returns first missing positional, if any, otherwise None.",
  "output_code": "def validate_expected_params(\n    params: Sequence[Parameter], expected_params: Sequence[str]\n) -> Optional[str]:\n    \n    expected_idx = 0\n    for expected_param in expected_params:\n        if expected_idx >= len(params) or not _is_param_valid(params[expected_idx], expected_param):\n            return expected_param\n        expected_idx += 1\n    return None",
  "input_contexts": [
    {
      "id": "dagster-io_dagster_7164_3",
      "input_code": "def dagster_type_loader(\n    config_schema: object, required_resource_keys: Optional[AbstractSet[str]] = None\n) -> Callable[[DagsterTypeLoaderFn], DagsterTypeLoaderFromDecorator]:\n    \n    from dagster._config import resolve_to_config_type\n\n    config_type = resolve_to_config_type(config_schema)\n    assert isinstance(\n        config_type, ConfigType\n    ), f\"{config_schema} could not be resolved to config type\"\n    EXPECTED_POSITIONALS = [\"context\", \"*\"]\n\n    def wrapper(func: DagsterTypeLoaderFn) -> DagsterTypeLoaderFromDecorator:\n        params = get_function_params(func)\n        missing_positional = validate_expected_params(params, EXPECTED_POSITIONALS)\n        if missing_positional:\n            raise DagsterInvalidDefinitionError(\n                f\"@dagster_type_loader '{func.__name__}' decorated function does not have required\"\n                f\" positional parameter '{missing_positional}'. @dagster_type_loader decorated\"\n                \" functions should only have keyword arguments that match input names and a first\"\n                \" positional parameter named 'context'.\"\n            )\n\n        return _create_type_loader_for_decorator(\n            config_type, func, required_resource_keys\n        )\n\n    return wrapper\n"
    },
    {
      "id": "dagster-io_dagster_7164_4",
      "input_code": "def test_one_required_positional_param():\n    positionals = [\"bar\"]\n    fn_params = get_function_params(decorated_function_one_positional())\n    assert {fn_param.name for fn_param in fn_params} == {\"bar\"}\n    assert not validate_expected_params(fn_params, positionals)\n"
    },
    {
      "id": "dagster-io_dagster_7164_2",
      "input_code": "    def __call__(self, resource_fn: ResourceFunction) -> ResourceDefinition:\n        check.callable_param(resource_fn, \"resource_fn\")\n\n        any_name = [\"*\"] if has_at_least_one_parameter(resource_fn) else []\n\n        params = get_function_params(resource_fn)\n\n        missing_positional = validate_expected_params(params, any_name)\n        if missing_positional:\n            raise DagsterInvalidDefinitionError(\n                f\"@resource decorated function '{resource_fn.__name__}' expects a single \"\n                \"positional argument.\"\n            )\n\n        extras = params[len(any_name) :]\n\n        required_extras = list(filter(is_required_param, extras))\n        if required_extras:\n            raise DagsterInvalidDefinitionError(\n                f\"@resource decorated function '{resource_fn.__name__}' expects only a single\"\n                \" positional required argument. Got required extra params\"\n                f\" {', '.join(positional_arg_name_list(required_extras))}\"\n            )\n\n        resource_def = ResourceDefinition.dagster_internal_init(\n            resource_fn=resource_fn,\n            config_schema=self.config_schema,\n            description=self.description or format_docstring_for_description(resource_fn),\n            version=self.version,\n            required_resource_keys=self.required_resource_keys,\n        )\n\n        update_wrapper(resource_def, wrapped=resource_fn)\n\n        return resource_def\n"
    },
    {
      "id": "dagster-io_dagster_7164_1",
      "input_code": "def _validate_hook_fn_params(fn, expected_positionals):\n    params = get_function_params(fn)\n    missing_positional = validate_expected_params(params, expected_positionals)\n    if missing_positional:\n        raise DagsterInvalidDefinitionError(\n            f\"'{fn.__name__}' decorated function does not have required positional \"\n            f\"parameter '{missing_positional}'. Hook functions should only have keyword arguments \"\n            \"that match input names and a first positional parameter named 'context' and \"\n            \"a second positional parameter named 'event_list'.\"\n        )\n"
    },
    {
      "id": "dagster-io_dagster_7164_5",
      "input_code": "def test_required_positional_parameters_not_missing():\n    positionals = [\"bar\", \"baz\"]\n\n    fn_params = get_function_params(decorated_function_two_positionals_one_kwarg())\n    assert {fn_param.name for fn_param in fn_params} == {\"bar\", \"qux\", \"baz\"}\n\n    assert not validate_expected_params(fn_params, positionals)\n\n    fn_params = get_function_params(decorated_function_one_positional())\n    assert validate_expected_params(fn_params, positionals) == \"baz\"\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport inspect\nfrom typing import Sequence, Optional\n\n<testcase_1>\nparams = [\n    inspect.Parameter(name='context', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='event_list', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='input1', kind=inspect.Parameter.KEYWORD_ONLY)\n]\nexpected_params = ['context', 'event_list', 'input1']\n\n<testcase_2>\nparams = [\n    inspect.Parameter(name='bar', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='baz', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='qux', kind=inspect.Parameter.KEYWORD_ONLY)\n]\nexpected_params = ['bar', 'baz']\n\n<testcase_3>\nparams = [\n    inspect.Parameter(name='context', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='input1', kind=inspect.Parameter.KEYWORD_ONLY)\n]\nexpected_params = ['context', 'event_list']\n\n<testcase_4>\nparams = [\n    inspect.Parameter(name='foo', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD)\n]\nexpected_params = ['bar']\n\n<testcase_5>\nparams = [\n    inspect.Parameter(name='context', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='input1', kind=inspect.Parameter.KEYWORD_ONLY),\n    inspect.Parameter(name='input2', kind=inspect.Parameter.KEYWORD_ONLY)\n]\nexpected_params = ['context', '*']"
  ],
  "gpt_output": "<needimport>\nimport inspect\nfrom typing import Sequence, Optional\n\n<testcase_1>\nparams = [\n    inspect.Parameter(name='context', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='event_list', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='input1', kind=inspect.Parameter.KEYWORD_ONLY)\n]\nexpected_params = ['context', 'event_list', 'input1']\n\n<testcase_2>\nparams = [\n    inspect.Parameter(name='bar', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='baz', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='qux', kind=inspect.Parameter.KEYWORD_ONLY)\n]\nexpected_params = ['bar', 'baz']\n\n<testcase_3>\nparams = [\n    inspect.Parameter(name='context', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='input1', kind=inspect.Parameter.KEYWORD_ONLY)\n]\nexpected_params = ['context', 'event_list']\n\n<testcase_4>\nparams = [\n    inspect.Parameter(name='foo', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD)\n]\nexpected_params = ['bar']\n\n<testcase_5>\nparams = [\n    inspect.Parameter(name='context', kind=inspect.Parameter.POSITIONAL_OR_KEYWORD),\n    inspect.Parameter(name='input1', kind=inspect.Parameter.KEYWORD_ONLY),\n    inspect.Parameter(name='input2', kind=inspect.Parameter.KEYWORD_ONLY)\n]\nexpected_params = ['context', '*']",
  "needimport": "import inspect\nfrom typing import Sequence, Optional\n\n",
  "test_results": {
    "ans1": null,
    "ans2": null,
    "ans3": "event_list",
    "ans4": "bar",
    "ans5": null
  }
}