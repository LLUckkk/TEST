{
  "input_header": "def has_input_asset(self, key: \"AssetKey\") -> bool:",
  "input_docstring": null,
  "output_code": "    def has_input_asset(self, key: \"AssetKey\") -> bool:\n        return key in self.input_data_versions and key in self.input_storage_ids",
  "input_contexts": [
    {
      "id": "dagster-io_dagster_8018_1",
      "input_code": "    def _get_stale_causes_materialized(self, key: \"AssetKeyPartitionKey\") -> Iterator[StaleCause]:\n        from dagster._core.definitions.events import AssetKeyPartitionKey\n\n        code_version = self.asset_graph.get(key.asset_key).code_version\n        provenance = self._get_current_data_provenance(key=key)\n\n        asset_deps = self.asset_graph.get(key.asset_key).parent_keys\n\n        materialization = check.not_none(self._get_latest_data_version_record(key=key))\n        materialization_time = materialization.timestamp\n\n        if provenance:\n            if code_version and code_version != provenance.code_version:\n                yield StaleCause(key, StaleCauseCategory.CODE, \"has a new code version\")\n\n            removed_deps = set(provenance.input_data_versions.keys()) - set(asset_deps)\n            for dep_key in removed_deps:\n                yield StaleCause(\n                    key,\n                    StaleCauseCategory.DEPENDENCIES,\n                    f\"removed dependency on {dep_key.to_user_string()}\",\n                    AssetKeyPartitionKey(dep_key, None),\n                )\n\n        partition_deps = self._get_partition_dependencies(key=key)\n        for dep_key in sorted(partition_deps):\n            dep_asset = self.asset_graph.get(dep_key.asset_key)\n            if provenance:\n                if not provenance.has_input_asset(dep_key.asset_key):\n                    yield StaleCause(\n                        key,\n                        StaleCauseCategory.DEPENDENCIES,\n                        f\"has a new dependency on {dep_key.asset_key.to_user_string()}\",\n                        dep_key,\n                    )\n                elif self._is_dep_updated(provenance, dep_key):\n                    report_data_version = (\n                        dep_asset.code_version is not None\n                        or self._is_current_data_version_user_provided(key=dep_key)\n                    )\n                    yield StaleCause(\n                        key,\n                        StaleCauseCategory.DATA,\n                        (\n                            \"has a new dependency data version\"\n                            if report_data_version\n                            else \"has a new dependency materialization\"\n                        ),\n                        dep_key,\n                        [\n                            StaleCause(\n                                dep_key,\n                                StaleCauseCategory.DATA,\n                                (\n                                    \"has a new data version\"\n                                    if report_data_version\n                                    else \"has a new materialization\"\n                                ),\n                            )\n                        ],\n                    )\n            elif not dep_asset.is_external:\n                dep_materialization = self._get_latest_data_version_record(key=dep_key)\n                if dep_materialization is None:\n                    yield StaleCause(key, StaleCauseCategory.DATA, \"has a new input\", dep_key)\n                elif dep_materialization.timestamp > materialization_time:\n                    yield StaleCause(\n                        key,\n                        StaleCauseCategory.DATA,\n                        \"has a new dependency materialization\",\n                        dep_key,\n                        [\n                            StaleCause(\n                                dep_key,\n                                StaleCauseCategory.DATA,\n                                \"has a new materialization\",\n                            )\n                        ],\n                    )\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport dagster\nfrom dagster._core.definitions.events import AssetKey\n\n<testcase_1>\nkey = AssetKey([\"asset_1\"])\n\n<testcase_2>\nkey = AssetKey([\"asset_2\"])\n\n<testcase_3>\nkey = AssetKey([\"asset_3\"])\n\n<testcase_4>\nkey = AssetKey([\"asset_4\"])\n\n<testcase_5>\nkey = AssetKey([\"asset_5\"])"
  ],
  "gpt_output": "<needimport>\nimport dagster\nfrom dagster._core.definitions.events import AssetKey\n\n<testcase_1>\nkey = AssetKey([\"asset_1\"])\n\n<testcase_2>\nkey = AssetKey([\"asset_2\"])\n\n<testcase_3>\nkey = AssetKey([\"asset_3\"])\n\n<testcase_4>\nkey = AssetKey([\"asset_4\"])\n\n<testcase_5>\nkey = AssetKey([\"asset_5\"])",
  "needimport": "import dagster\nfrom dagster._core.definitions.events import AssetKey\n\n",
  "test_results": {
    "ans1": true,
    "ans2": true,
    "ans3": false,
    "ans4": false,
    "ans5": true
  }
}