{
  "input_header": "def get_vpc_peering_connection(self, vpc_pcx_id: str) -> VPCPeeringConnection:",
  "input_docstring": null,
  "output_code": "    def get_vpc_peering_connection(self, vpc_pcx_id: str) -> VPCPeeringConnection:\n        if vpc_pcx_id not in self.vpc_pcxs:\n            raise InvalidVPCPeeringConnectionIdError(vpc_pcx_id)\n        return self.vpc_pcxs[vpc_pcx_id]",
  "input_contexts": [
    {
      "id": "getmoto_moto_4533_3",
      "input_code": "    def replace_route(\n        self,\n        route_table_id: str,\n        destination_cidr_block: str,\n        destination_ipv6_cidr_block: Optional[str] = None,\n        destination_prefix_list_id: Optional[str] = None,\n        nat_gateway_id: Optional[str] = None,\n        egress_only_igw_id: Optional[str] = None,\n        transit_gateway_id: Optional[str] = None,\n        gateway_id: Optional[str] = None,\n        instance_id: Optional[str] = None,\n        interface_id: Optional[str] = None,\n        vpc_peering_connection_id: Optional[str] = None,\n    ) -> Route:\n        cidr = destination_cidr_block\n        if destination_ipv6_cidr_block:\n            cidr = destination_ipv6_cidr_block\n        if destination_prefix_list_id:\n            cidr = destination_prefix_list_id\n        route_table = self.get_route_table(route_table_id)\n        route_id = generate_route_id(route_table.id, cidr, destination_ipv6_cidr_block)\n        try:\n            route = route_table.routes[route_id]\n        except KeyError:\n            raise InvalidParameterValueErrorReplaceRoute(cidr) from None\n\n        route.gateway = None\n        route.nat_gateway = None\n        route.egress_only_igw = None\n        route.transit_gateway = None\n        if gateway_id:\n            if EC2_RESOURCE_TO_PREFIX[\"vpn-gateway\"] in gateway_id:\n                route.gateway = self.get_vpn_gateway(gateway_id)\n            elif EC2_RESOURCE_TO_PREFIX[\"internet-gateway\"] in gateway_id:\n                route.gateway = self.get_internet_gateway(gateway_id)\n\n        if nat_gateway_id is not None:\n            route.nat_gateway = self.nat_gateways.get(nat_gateway_id)\n        if egress_only_igw_id is not None:\n            route.egress_only_igw = self.get_egress_only_igw(egress_only_igw_id)\n        if transit_gateway_id is not None:\n            route.transit_gateway = self.transit_gateways.get(transit_gateway_id)\n        if destination_prefix_list_id is not None:\n            route.prefix_list = self.managed_prefix_lists.get(                destination_prefix_list_id\n            )\n\n        route.instance = self.get_instance(instance_id) if instance_id else None\n        route.interface = (\n            self.get_network_interface(interface_id) if interface_id else None        )\n        route.vpc_pcx = (\n            self.get_vpc_peering_connection(vpc_peering_connection_id)            if vpc_peering_connection_id\n            else None\n        )\n\n        route_table.routes[route.id] = route\n        return route\n"
    },
    {
      "id": "getmoto_moto_4533_7",
      "input_code": "    def modify_vpc_peering_connection_options(\n        self,\n        vpc_pcx_id: str,\n        accepter_options: Optional[Dict[str, Any]] = None,\n        requester_options: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        vpc_pcx = self.get_vpc_peering_connection(vpc_pcx_id)\n        if not vpc_pcx:\n            raise InvalidVPCPeeringConnectionIdError(vpc_pcx_id)\n        if accepter_options:\n            vpc_pcx.accepter_options.update(accepter_options)\n        if requester_options:\n            vpc_pcx.requester_options.update(requester_options)\n"
    },
    {
      "id": "getmoto_moto_4533_4",
      "input_code": "    def delete_vpc_peering_connection(self, vpc_pcx_id: str) -> VPCPeeringConnection:\n        deleted = self.get_vpc_peering_connection(vpc_pcx_id)\n        deleted._status.deleted(deleter_id=self.account_id)\n        return deleted\n"
    },
    {
      "id": "getmoto_moto_4533_5",
      "input_code": "    def accept_vpc_peering_connection(self, vpc_pcx_id: str) -> VPCPeeringConnection:\n        vpc_pcx = self.get_vpc_peering_connection(vpc_pcx_id)\n\n        req_account_id = vpc_pcx.vpc.owner_id\n        acp_account_id = vpc_pcx.peer_vpc.owner_id\n        if req_account_id != acp_account_id and self.account_id != acp_account_id:\n            raise OperationNotPermitted5(self.account_id, vpc_pcx_id, \"accept\")\n\n        pcx_req_region = vpc_pcx.vpc.region\n        pcx_acp_region = vpc_pcx.peer_vpc.region\n        if pcx_req_region != pcx_acp_region and self.region_name == pcx_req_region:\n            raise OperationNotPermitted2(self.region_name, vpc_pcx.id, pcx_acp_region)\n\n        if vpc_pcx._status.code != \"pending-acceptance\":\n            raise InvalidVPCPeeringConnectionStateTransitionError(vpc_pcx.id)\n        vpc_pcx._status.accept()\n        return vpc_pcx\n"
    },
    {
      "id": "getmoto_moto_4533_6",
      "input_code": "    def reject_vpc_peering_connection(self, vpc_pcx_id: str) -> VPCPeeringConnection:\n        vpc_pcx = self.get_vpc_peering_connection(vpc_pcx_id)\n\n        req_account_id = vpc_pcx.vpc.owner_id\n        acp_account_id = vpc_pcx.peer_vpc.owner_id\n        if req_account_id != acp_account_id and self.account_id != acp_account_id:\n            raise OperationNotPermitted5(self.account_id, vpc_pcx_id, \"reject\")\n\n        pcx_req_region = vpc_pcx.vpc.region\n        pcx_acp_region = vpc_pcx.peer_vpc.region\n        if pcx_req_region != pcx_acp_region and self.region_name == pcx_req_region:\n            raise OperationNotPermitted3(self.region_name, vpc_pcx.id, pcx_acp_region)\n\n        if vpc_pcx._status.code != \"pending-acceptance\":\n            raise InvalidVPCPeeringConnectionStateTransitionError(vpc_pcx.id)\n        vpc_pcx._status.reject()\n        return vpc_pcx\n"
    },
    {
      "id": "getmoto_moto_4533_1",
      "input_code": "    def do_resources_exist(self, resource_ids: List[str]) -> bool:\n        for resource_id in resource_ids:\n            resource_prefix = get_prefix(resource_id)\n            if resource_prefix == EC2_RESOURCE_TO_PREFIX[\"customer-gateway\"]:\n                self.get_customer_gateway(customer_gateway_id=resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"dhcp-options\"]:\n                self.describe_dhcp_options(dhcp_options_ids=[resource_id])\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"image\"]:\n                self.describe_images(ami_ids=[resource_id])\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"instance\"]:\n                self.get_instance_by_id(instance_id=resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"internet-gateway\"]:\n                self.describe_internet_gateways(internet_gateway_ids=[resource_id])\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"launch-template\"]:\n                self.get_launch_template(resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"network-acl\"]:\n                self.describe_network_acls()\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"network-interface\"]:\n                self.describe_network_interfaces(\n                    filters={\"network-interface-id\": resource_id}\n                )\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"reserved-instance\"]:\n                self.raise_not_implemented_error(\"DescribeReservedInstances\")\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"route-table\"]:\n                self.get_route_table(route_table_id=resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"security-group\"]:\n                self.describe_security_groups(group_ids=[resource_id])\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"snapshot\"]:\n                self.get_snapshot(snapshot_id=resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"spot-instance-request\"]:\n                self.describe_spot_instance_requests(\n                    filters={\"spot-instance-request-id\": resource_id}\n                )\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"subnet\"]:\n                self.get_subnet(subnet_id=resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"volume\"]:\n                self.get_volume(volume_id=resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"vpc\"]:\n                self.get_vpc(vpc_id=resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"vpc-endpoint-service\"]:\n                self.get_vpc_endpoint_service(resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"vpc-peering-connection\"]:\n                self.get_vpc_peering_connection(vpc_pcx_id=resource_id)\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"vpn-connection\"]:\n                self.describe_vpn_connections(vpn_connection_ids=[resource_id])\n            elif resource_prefix == EC2_RESOURCE_TO_PREFIX[\"vpn-gateway\"]:\n                self.get_vpn_gateway(vpn_gateway_id=resource_id)\n            elif (\n                resource_prefix\n                == EC2_RESOURCE_TO_PREFIX[\"iam-instance-profile-association\"]\n            ):\n                self.describe_iam_instance_profile_associations(\n                    association_ids=[resource_id]\n                )\n        return True\n"
    },
    {
      "id": "getmoto_moto_4533_2",
      "input_code": "    def create_route(\n        self,\n        route_table_id: str,\n        destination_cidr_block: Optional[str],\n        destination_ipv6_cidr_block: Optional[str] = None,\n        destination_prefix_list_id: Optional[str] = None,\n        local: bool = False,\n        gateway_id: Optional[str] = None,\n        instance_id: Optional[str] = None,\n        nat_gateway_id: Optional[str] = None,\n        egress_only_igw_id: Optional[str] = None,\n        transit_gateway_id: Optional[str] = None,\n        interface_id: Optional[str] = None,\n        vpc_peering_connection_id: Optional[str] = None,\n        carrier_gateway_id: Optional[str] = None,\n        vpc_endpoint_id: Optional[str] = None,\n    ) -> Route:\n        gateway = None\n        nat_gateway = None\n        transit_gateway = None\n        egress_only_igw = None\n        interface = None\n        destination_prefix_list = None\n        carrier_gateway = None\n\n        if vpc_endpoint_id:\n            vpce = self.describe_vpc_endpoints(vpc_end_point_ids=[vpc_endpoint_id])\n            if not vpce[0].endpoint_type == \"GatewayLoadBalancer\":\n                raise RouteNotSupportedError(vpc_endpoint_id)\n\n        route_table = self.get_route_table(route_table_id)\n\n        if interface_id:\n            interface = self.get_network_interface(interface_id)\n\n        else:\n            if gateway_id:\n                if EC2_RESOURCE_TO_PREFIX[\"vpn-gateway\"] in gateway_id:\n                    gateway = self.get_vpn_gateway(gateway_id)\n                elif EC2_RESOURCE_TO_PREFIX[\"internet-gateway\"] in gateway_id:\n                    gateway = self.get_internet_gateway(gateway_id)\n                elif EC2_RESOURCE_TO_PREFIX[\"vpc-endpoint\"] in gateway_id:\n                    gateway = self.get_vpc_end_point(gateway_id)\n\n            if destination_cidr_block:\n                self.__validate_destination_cidr_block(\n                    destination_cidr_block, route_table\n                )\n\n            if nat_gateway_id is not None:\n                nat_gateway = self.nat_gateways.get(nat_gateway_id)\n            if egress_only_igw_id is not None:\n                egress_only_igw = self.get_egress_only_igw(egress_only_igw_id)\n            if transit_gateway_id is not None:\n                transit_gateway = self.transit_gateways.get(transit_gateway_id)\n            if destination_prefix_list_id is not None:\n                destination_prefix_list = self.managed_prefix_lists.get(                    destination_prefix_list_id\n                )\n            if carrier_gateway_id is not None:\n                carrier_gateway = self.carrier_gateways.get(carrier_gateway_id)\n\n        route = Route(\n            route_table,\n            destination_cidr_block,\n            destination_ipv6_cidr_block,\n            destination_prefix_list,\n            local=local,\n            gateway=gateway,\n            instance=self.get_instance(instance_id) if instance_id else None,            nat_gateway=nat_gateway,\n            egress_only_igw=egress_only_igw,\n            transit_gateway=transit_gateway,\n            interface=interface,\n            carrier_gateway=carrier_gateway,\n            vpc_endpoint_id=vpc_endpoint_id,\n            vpc_pcx=self.get_vpc_peering_connection(vpc_peering_connection_id)            if vpc_peering_connection_id\n            else None,\n        )\n        route_table.routes[route.id] = route\n        return route\n"
    }
  ],
  "generated_inputs": [
    "```python\n<needimport>\nimport uuid\n\n<testcase_1>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n\n<testcase_2>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n\n<testcase_3>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n\n<testcase_4>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n\n<testcase_5>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n```"
  ],
  "gpt_output": "```python\n<needimport>\nimport uuid\n\n<testcase_1>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n\n<testcase_2>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n\n<testcase_3>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n\n<testcase_4>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n\n<testcase_5>\nvpc_pcx_id = \"pcx-\" + str(uuid.uuid4())[:8]\n```",
  "needimport": "import uuid\n\n",
  "test_results": {
    "ans1": {
      "vpc_pcx_id": "pcx-12345678"
    },
    "ans2": {
      "vpc_pcx_id": "pcx-12345678"
    },
    "ans3": {
      "vpc_pcx_id": "pcx-12345678"
    },
    "ans4": {
      "vpc_pcx_id": "pcx-12345678"
    },
    "ans5": {
      "vpc_pcx_id": "pcx-12345678"
    }
  }
}