{
  "input_header": "def array_to_string(array, col_delim=\" \", row_delim=\"\\n\", digits=8, value_format=\"{}\"):",
  "input_docstring": "Convert a 1 or 2D array into a string with a specified number\nof digits and delimiter. The reason this exists is that the\nbasic numpy array to string conversions are surprisingly bad.\n\nParameters\n------------\narray : (n,) or (n, d) float or int\n   Data to be converted\n   If shape is (n,) only column delimiter will be used\ncol_delim : str\n  What string should separate values in a column\nrow_delim : str\n  What string should separate values in a row\ndigits : int\n  How many digits should floating point numbers include\nvalue_format : str\n   Format string for each value or sequence of values\n   If multiple values per value_format it must divide\n   into array evenly.\n\nReturns\n----------\nformatted : str\n   String representation of original array",
  "output_code": "def array_to_string(array, col_delim=\" \", row_delim=\"\\n\", digits=8, value_format=\"{}\"):\n    \n    array = np.asanyarray(array)\n    digits = int(digits)\n    row_delim = str(row_delim)\n    col_delim = str(col_delim)\n    value_format = str(value_format)\n\n    if len(array.shape) > 2:\n        raise ValueError(\"conversion only works on 1D/2D arrays not %s!\", str(array.shape))\n\n    if array.dtype.names is not None:\n        raise ValueError(\"array is  structured, use structured_array_to_string instead\")\n\n    repeats = value_format.count(\"{\")\n\n    if array.dtype.kind in [\"i\", \"u\"]:\n        format_str = value_format + col_delim\n    elif array.dtype.kind == \"f\":\n        format_str = value_format.replace(\"{}\", \"{:.\" + str(digits) + \"f}\") + col_delim\n    else:\n        raise ValueError(\"dtype %s not convertible!\", array.dtype.name)\n\n    end_junk = len(col_delim)\n    if len(array.shape) == 2:\n        format_str *= array.shape[1]\n        format_str = format_str[: -len(col_delim)] + row_delim\n        end_junk = len(row_delim)\n\n    format_str *= len(array)\n\n    shaped = np.tile(array.reshape((-1, 1)), (1, repeats)).reshape(-1)\n\n    formatted = format_str.format(*shaped)[:-end_junk]\n\n    return formatted",
  "input_contexts": [
    {
      "id": "Genesis-Embodied-AI_Genesis_3697_2",
      "input_code": "def export_off(mesh, digits=10):\n    \n    digits = int(digits)\n    faces_stacked = np.column_stack((np.ones(len(mesh.faces)) * 3, mesh.faces)).astype(np.int64)\n    export = \"OFF\\n\"\n    export += str(len(mesh.vertices)) + \" \" + str(len(mesh.faces)) + \" 0\\n\"\n    export += util.array_to_string(mesh.vertices, col_delim=\" \", row_delim=\"\\n\", digits=digits) + \"\\n\"\n    export += util.array_to_string(faces_stacked, col_delim=\" \", row_delim=\"\\n\")\n    return export\n"
    },
    {
      "id": "Genesis-Embodied-AI_Genesis_3697_3",
      "input_code": "def export_xyz(cloud, write_colors=True, delimiter=None):\n    \n    if not isinstance(cloud, PointCloud):\n        raise ValueError(\"object must be PointCloud\")\n\n    data = cloud.vertices\n    if write_colors and hasattr(cloud, \"colors\") and cloud.colors is not None:\n        data = np.hstack((data, cloud.colors))\n\n    if delimiter is None:\n        delimiter = \" \"\n    export = util.array_to_string(data, col_delim=delimiter)\n\n    return export\n"
    },
    {
      "id": "Genesis-Embodied-AI_Genesis_3697_1",
      "input_code": "def export_obj(\n    mesh,\n    include_normals=None,\n    include_color=True,\n    include_texture=True,\n    return_texture=False,\n    write_texture=True,\n    resolver=None,\n    digits=8,\n    mtl_name=None,\n    header=\"https://github.com/mikedh/trimesh\",\n):\n    \n    face_formats = {(\"v\",): \"{}\", (\"v\", \"vn\"): \"{}//{}\", (\"v\", \"vt\"): \"{}/{}\", (\"v\", \"vn\", \"vt\"): \"{}/{}/{}\"}\n\n    if util.is_instance_named(mesh, \"Trimesh\"):\n        meshes = [mesh]\n    elif util.is_instance_named(mesh, \"Scene\"):\n        meshes = mesh.dump()\n    elif util.is_instance_named(mesh, \"PointCloud\"):\n        meshes = [mesh]\n    else:\n        raise ValueError(\"must be Trimesh or Scene!\")\n\n    objects = deque([])\n    counts = {\"v\": 0, \"vn\": 0, \"vt\": 0}\n    materials = {}\n    materials_name = set()\n\n    for current in meshes:\n        face_type = [\"v\"]\n        if include_color and current.visual.kind in [\"vertex\", \"face\"] and len(current.visual.vertex_colors):\n\n            v_blob = np.column_stack((current.vertices, to_float(current.visual.vertex_colors[:, :3])))\n        else:\n            v_blob = current.vertices\n\n        export = deque([\"v \" + util.array_to_string(v_blob, col_delim=\" \", row_delim=\"\\nv \", digits=digits)])\n\n        if include_normals is None:\n            include_normals = \"vertex_normals\" in current._cache.cache\n\n        if include_normals:\n            try:\n                converted = util.array_to_string(\n                    current.vertex_normals, col_delim=\" \", row_delim=\"\\nvn \", digits=digits\n                )\n                face_type.append(\"vn\")\n                export.append(\"vn \" + converted)\n            except BaseException:\n                log.debug(\"failed to convert vertex normals\", exc_info=True)\n\n        if include_texture and hasattr(current.visual, \"uv\"):\n            try:\n                material = current.visual.material\n                if hasattr(material, \"to_simple\"):\n                    material = material.to_simple()\n\n                hashed = hash(material)\n                if hashed not in materials:\n                    name = util.unique_name(material.name, materials_name)\n                    materials_name.add(name)\n                    materials[hashed] = material.to_obj(name=name)\n\n                tex_name = materials[hashed][1]\n\n                if len(np.shape(getattr(current.visual, \"uv\", None))) == 2:\n                    converted = util.array_to_string(current.visual.uv, col_delim=\" \", row_delim=\"\\nvt \", digits=digits)\n                    face_type.append(\"vt\")\n                    export.append(\"vt \" + converted)\n                export.appendleft(\"usemtl {}\".format(tex_name))\n            except BaseException:\n                log.debug(\"failed to convert UV coordinates\", exc_info=True)\n\n        face_format = face_formats[tuple(face_type)]\n        if hasattr(current, \"faces\"):\n            export.append(\n                \"f \"\n                + util.array_to_string(\n                    current.faces + 1 + counts[\"v\"], col_delim=\" \", row_delim=\"\\nf \", value_format=face_format\n                )\n            )\n        counts[\"v\"] += len(current.vertices)\n\n        if \"name\" in current.metadata:\n            export.appendleft(\"\\no {}\".format(current.metadata[\"name\"]))\n        objects.append(\"\\n\".join(export))\n\n    if len(materials) > 0:\n        mtl_lib = []\n        mtl_data = {}\n        for data, _ in materials.values():\n            for file_name, file_data in data.items():\n                if file_name.lower().endswith(\".mtl\"):\n                    mtl_lib.append(file_data)\n                elif file_name not in mtl_data:\n                    mtl_data[file_name] = file_data\n                else:\n                    log.warning(\"not writing {}\".format(file_name))\n\n        if mtl_name is None:\n            mtl_name = \"material.mtl\"\n\n        if header is not None:\n            prepend = \"# {}\\n\\n\".format(header).encode(\"utf-8\")\n        else:\n            prepend = b\"\"\n\n        mtl_data[mtl_name] = prepend + b\"\\n\\n\".join(mtl_lib)\n        objects.appendleft(\"mtllib {}\".format(mtl_name))\n\n    if header is not None:\n        objects.appendleft(\"# {}\".format(header))\n    text = \"\\n\".join(objects)\n\n    if write_texture and resolver is not None and len(materials) > 0:\n        [resolver.write(k, v) for k, v in mtl_data.items()]\n\n    if return_texture:\n        return text, mtl_data\n\n    return text\n"
    }
  ],
  "generated_inputs": [
    "```python\n<needimport>\nimport numpy as np\n\n<testcase_1>\narray = np.array([1.23456789, 2.34567891, 3.45678912])\ncol_delim = \", \"\nrow_delim = \"\\n\"\ndigits = 5\nvalue_format = \"{}\"\n\n<testcase_2>\narray = np.array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6]])\ncol_delim = \"; \"\nrow_delim = \"\\n\"\ndigits = 2\nvalue_format = \"{}\"\n\n<testcase_3>\narray = np.array([10, 20, 30, 40])\ncol_delim = \" | \"\nrow_delim = \"\\n\"\ndigits = 0\nvalue_format = \"{}\"\n\n<testcase_4>\narray = np.array([[123, 456], [789, 101]])\ncol_delim = \" - \"\nrow_delim = \" | \"\ndigits = 0\nvalue_format = \"{}\"\n\n<testcase_5>\narray = np.array([[0.123456789, 0.987654321], [0.111111111, 0.999999999]])\ncol_delim = \" \"\nrow_delim = \"\\n\"\ndigits = 9\nvalue_format = \"{:.2e}\"\n```"
  ],
  "gpt_output": "```python\n<needimport>\nimport numpy as np\n\n<testcase_1>\narray = np.array([1.23456789, 2.34567891, 3.45678912])\ncol_delim = \", \"\nrow_delim = \"\\n\"\ndigits = 5\nvalue_format = \"{}\"\n\n<testcase_2>\narray = np.array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6]])\ncol_delim = \"; \"\nrow_delim = \"\\n\"\ndigits = 2\nvalue_format = \"{}\"\n\n<testcase_3>\narray = np.array([10, 20, 30, 40])\ncol_delim = \" | \"\nrow_delim = \"\\n\"\ndigits = 0\nvalue_format = \"{}\"\n\n<testcase_4>\narray = np.array([[123, 456], [789, 101]])\ncol_delim = \" - \"\nrow_delim = \" | \"\ndigits = 0\nvalue_format = \"{}\"\n\n<testcase_5>\narray = np.array([[0.123456789, 0.987654321], [0.111111111, 0.999999999]])\ncol_delim = \" \"\nrow_delim = \"\\n\"\ndigits = 9\nvalue_format = \"{:.2e}\"\n```",
  "needimport": "import numpy as np\n\n",
  "test_results": {
    "ans1": "1.23457, 2.34568, 3.45679",
    "ans2": "1.10; 2.20; 3.30\n4.40; 5.50; 6.60",
    "ans3": "10 | 20 | 30 | 40",
    "ans4": "123 - 456 | 789 - 101",
    "ans5": "1.23e-01 9.88e-01\n1.11e-01 1.00e+00"
  }
}