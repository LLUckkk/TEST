{
  "input_header": "def _sparse_decision_function(self, X):",
  "input_docstring": null,
  "output_code": "    def _sparse_decision_function(self, X):\n        X.data = np.asarray(X.data, dtype=np.float64, order=\"C\")\n\n        kernel = self.kernel\n        if hasattr(kernel, \"__call__\"):\n            kernel = \"precomputed\"\n\n        kernel_type = self._sparse_kernels.index(kernel)\n\n        return libsvm_sparse.libsvm_sparse_decision_function(\n            X.data,\n            X.indices,\n            X.indptr,\n            self.support_vectors_.data,\n            self.support_vectors_.indices,\n            self.support_vectors_.indptr,\n            self._dual_coef_.data,\n            self._intercept_,\n            LIBSVM_IMPL.index(self._impl),\n            kernel_type,\n            self.degree,\n            self._gamma,\n            self.coef0,\n            self.tol,\n            self.C,\n            getattr(self, \"class_weight_\", np.empty(0)),\n            self.nu,\n            self.epsilon,\n            self.shrinking,\n            self.probability,\n            self._n_support,\n            self._probA,\n            self._probB,\n        )",
  "input_contexts": [
    {
      "id": "scikit-learn_scikit-learn_7553_1",
      "input_code": "    def _decision_function(self, X):\n        \n        X = self._validate_for_predict(X)\n        X = self._compute_kernel(X)\n\n        if self._sparse:\n            dec_func = self._sparse_decision_function(X)\n        else:\n            dec_func = self._dense_decision_function(X)\n\n        if self._impl in [\"c_svc\", \"nu_svc\"] and len(self.classes_) == 2:\n            return -dec_func.ravel()\n\n        return dec_func\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport numpy as np\nimport scipy.sparse as sp\nfrom sklearn.svm import SVC\n\n<testcase_1>\nX = sp.csr_matrix([[0, 1, 2], [3, 4, 5]], dtype=np.float64)\nself = SVC(kernel='linear', probability=True)\nself._sparse = True\nself._impl = 'c_svc'\nself.classes_ = np.array([0, 1])\nself.support_vectors_ = sp.csr_matrix([[0, 1, 2], [3, 4, 5]], dtype=np.float64)\nself._dual_coef_ = sp.csr_matrix([[0.1, 0.2]], dtype=np.float64)\nself._intercept_ = np.array([0.5])\nself._sparse_kernels = ['linear', 'poly', 'rbf', 'sigmoid', 'precomputed']\nself.degree = 3\nself._gamma = 'scale'\nself.coef0 = 0.0\nself.tol = 1e-3\nself.C = 1.0\nself.class_weight_ = np.empty(0)\nself.nu = 0.5\nself.epsilon = 0.1\nself.shrinking = True\nself.probability = True\nself._n_support = np.array([1, 1])\nself._probA = np.array([0.1])\nself._probB = np.array([0.2])\n\n<testcase_2>\nX = sp.csr_matrix([[1, 0, 0], [0, 1, 0]], dtype=np.float64)\nself = SVC(kernel='rbf', probability=False)\nself._sparse = True\nself._impl = 'nu_svc'\nself.classes_ = np.array([0, 1])\nself.support_vectors_ = sp.csr_matrix([[1, 0, 0], [0, 1, 0]], dtype=np.float64)\nself._dual_coef_ = sp.csr_matrix([[0.3, 0.4]], dtype=np.float64)\nself._intercept_ = np.array([0.6])\nself._sparse_kernels = ['linear', 'poly', 'rbf', 'sigmoid', 'precomputed']\nself.degree = 3\nself._gamma = 'auto'\nself.coef0 = 0.0\nself.tol = 1e-4\nself.C = 0.5\nself.class_weight_ = np.empty(0)\nself.nu = 0.3\nself.epsilon = 0.2\nself.shrinking = False\nself.probability = False\nself._n_support = np.array([1, 1])\nself._probA = np.array([0.2])\nself._probB = np.array([0.3])\n\n<testcase_3>\nX = sp.csr_matrix([[0, 0, 1], [1, 1, 1]], dtype=np.float64)\nself = SVC(kernel='poly', probability=True)\nself._sparse = True\nself._impl = 'c_svc'\nself.classes_ = np.array([0, 1])\nself.support_vectors_ = sp.csr_matrix([[0, 0, 1], [1, 1, 1]], dtype=np.float64)\nself._dual_coef_ = sp.csr_matrix([[0.5, 0.6]], dtype=np.float64)\nself._intercept_ = np.array([0.7])\nself._sparse_kernels = ['linear', 'poly', 'rbf', 'sigmoid', 'precomputed']\nself.degree = 2\nself._gamma = 'scale'\nself.coef0 = 1.0\nself.tol = 1e"
  ],
  "gpt_output": "<needimport>\nimport numpy as np\nimport scipy.sparse as sp\nfrom sklearn.svm import SVC\n\n<testcase_1>\nX = sp.csr_matrix([[0, 1, 2], [3, 4, 5]], dtype=np.float64)\nself = SVC(kernel='linear', probability=True)\nself._sparse = True\nself._impl = 'c_svc'\nself.classes_ = np.array([0, 1])\nself.support_vectors_ = sp.csr_matrix([[0, 1, 2], [3, 4, 5]], dtype=np.float64)\nself._dual_coef_ = sp.csr_matrix([[0.1, 0.2]], dtype=np.float64)\nself._intercept_ = np.array([0.5])\nself._sparse_kernels = ['linear', 'poly', 'rbf', 'sigmoid', 'precomputed']\nself.degree = 3\nself._gamma = 'scale'\nself.coef0 = 0.0\nself.tol = 1e-3\nself.C = 1.0\nself.class_weight_ = np.empty(0)\nself.nu = 0.5\nself.epsilon = 0.1\nself.shrinking = True\nself.probability = True\nself._n_support = np.array([1, 1])\nself._probA = np.array([0.1])\nself._probB = np.array([0.2])\n\n<testcase_2>\nX = sp.csr_matrix([[1, 0, 0], [0, 1, 0]], dtype=np.float64)\nself = SVC(kernel='rbf', probability=False)\nself._sparse = True\nself._impl = 'nu_svc'\nself.classes_ = np.array([0, 1])\nself.support_vectors_ = sp.csr_matrix([[1, 0, 0], [0, 1, 0]], dtype=np.float64)\nself._dual_coef_ = sp.csr_matrix([[0.3, 0.4]], dtype=np.float64)\nself._intercept_ = np.array([0.6])\nself._sparse_kernels = ['linear', 'poly', 'rbf', 'sigmoid', 'precomputed']\nself.degree = 3\nself._gamma = 'auto'\nself.coef0 = 0.0\nself.tol = 1e-4\nself.C = 0.5\nself.class_weight_ = np.empty(0)\nself.nu = 0.3\nself.epsilon = 0.2\nself.shrinking = False\nself.probability = False\nself._n_support = np.array([1, 1])\nself._probA = np.array([0.2])\nself._probB = np.array([0.3])\n\n<testcase_3>\nX = sp.csr_matrix([[0, 0, 1], [1, 1, 1]], dtype=np.float64)\nself = SVC(kernel='poly', probability=True)\nself._sparse = True\nself._impl = 'c_svc'\nself.classes_ = np.array([0, 1])\nself.support_vectors_ = sp.csr_matrix([[0, 0, 1], [1, 1, 1]], dtype=np.float64)\nself._dual_coef_ = sp.csr_matrix([[0.5, 0.6]], dtype=np.float64)\nself._intercept_ = np.array([0.7])\nself._sparse_kernels = ['linear', 'poly', 'rbf', 'sigmoid', 'precomputed']\nself.degree = 2\nself._gamma = 'scale'\nself.coef0 = 1.0\nself.tol = 1e",
  "needimport": "import numpy as np\nimport scipy.sparse as sp\nfrom sklearn.svm import SVC\n\n",
  "test_results": {
    "ans1": [
      -1.0
    ],
    "ans2": [],
    "ans3": [
      -1.0
    ],
    "ans4": [],
    "ans5": [
      -1.0
    ]
  }
}