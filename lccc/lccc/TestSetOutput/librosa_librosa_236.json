{
  "input_header": "def wavelet_lengths( *, freqs: ArrayLike, sr: float = 22050, window: _WindowSpec = \"hann\", filter_scale: float = 1, gamma: Optional[float] = 0, alpha: Optional[Union[float, np.ndarray]] = None, ) -> Tuple[np.ndarray, float]:",
  "input_docstring": "Return length of each filter in a wavelet basis.\n\nParameters\n----------\nfreqs : np.ndarray (positive)\n    Center frequencies of the filters (in Hz).\n    Must be in ascending order.\n\nsr : number > 0 [scalar]\n    Audio sampling rate\n\nwindow : str or callable\n    Window function to use on filters\n\nfilter_scale : float > 0 [scalar]\n    Resolution of filter windows. Larger values use longer windows.\n\ngamma : number >= 0 [scalar, optional]\n    Bandwidth offset for determining filter lengths, as used in\n    Variable-Q transforms.\n\n    Bandwidth for the k'th filter is determined by::\n\n        B[k] = alpha[k] * freqs[k] + gamma\n\n    ``alpha[k]`` is twice the relative difference between ``freqs[k+1]`` and ``freqs[k-1]``::\n\n        alpha[k] = (freqs[k+1]-freqs[k-1]) / (freqs[k+1]+freqs[k-1])\n\n    If ``freqs`` follows a geometric progression (as in CQT and VQT), the vector\n    ``alpha`` is constant and such that::\n\n        (1 + alpha) * freqs[k-1] = (1 - alpha) * freqs[k+1]\n\n    Furthermore, if ``gamma=0`` (default), ``alpha`` is such that even-``k`` and\n    odd-``k`` filters are interleaved::\n\n        freqs[k-1] + B[k-1] = freqs[k+1] - B[k+1]\n\n    If ``gamma=None`` is specified, then ``gamma`` is computed such\n    that each filter has bandwidth proportional to the equivalent\n    rectangular bandwidth (ERB) at frequency ``freqs[k]``::\n\n        gamma[k] = 24.7 * alpha[k] / 0.108\n\n    as derived by [#]_.\n\n    .. [#] Glasberg, Brian R., and Brian CJ Moore.\n        \"Derivation of auditory filter shapes from notched-noise data.\"\n        Hearing research 47.1-2 (1990): 103-138.\n\nalpha : number > 0 [optional]\n    Optional pre-computed relative bandwidth parameter.\n    Note that this must be provided if ``len(freqs)==1`` because bandwidth cannot be\n    inferred from a single frequency.\n    Otherwise, if left unspecified, it will be automatically derived by the rules\n    specified above.\n\nReturns\n-------\nlengths : np.ndarray\n    The length of each filter.\nf_cutoff : float\n    The lowest frequency at which all filters' main lobes have decayed by\n    at least 3dB.\n\n    This second output serves in cqt and vqt to ensure that all wavelet\n    bands remain below the Nyquist frequency.\n\nNotes\n-----\nThis function caches at level 10.\n\nRaises\n------\nParameterError\n    - If ``filter_scale`` is not strictly positive\n\n    - If ``gamma`` is a negative number\n\n    - If any frequencies are <= 0\n\n    - If the frequency array is not sorted in ascending order",
  "output_code": "def wavelet_lengths(\n    *,\n    freqs: ArrayLike,\n    sr: float = 22050,\n    window: _WindowSpec = \"hann\",\n    filter_scale: float = 1,\n    gamma: Optional[float] = 0,\n    alpha: Optional[Union[float, np.ndarray]] = None,\n) -> Tuple[np.ndarray, float]:\n    \n    freqs = np.asarray(freqs)\n    if filter_scale <= 0:\n        raise ParameterError(f\"filter_scale={filter_scale} must be positive\")\n\n    if gamma is not None and gamma < 0:\n        raise ParameterError(f\"gamma={gamma} must be non-negative\")\n\n    if np.any(freqs <= 0):\n        raise ParameterError(\"frequencies must be strictly positive\")\n\n    if len(freqs) > 1 and np.any(freqs[:-1] > freqs[1:]):\n        raise ParameterError(\n            f\"Frequency array={freqs} must be in strictly ascending order\"\n        )\n\n    if alpha is None:\n        alpha = _relative_bandwidth(freqs=freqs)\n    else:\n        alpha = np.asarray(alpha)\n\n    gamma_: Union[_FloatLike_co, np.ndarray]\n    if gamma is None:\n        gamma_ = alpha * 24.7 / 0.108\n    else:\n        gamma_ = gamma\n    Q = float(filter_scale) / alpha\n\n    f_cutoff = max(freqs * (1 + 0.5 * window_bandwidth(window) / Q) + 0.5 * gamma_)\n\n    lengths = Q * sr / (freqs + gamma_ / alpha)\n\n    return lengths, f_cutoff",
  "input_contexts": [
    {
      "id": "librosa_librosa_236_6",
      "input_code": "def test_cqt_white_noise(y_white, sr_white, fmin, n_bins, scale):\n\n    C = np.abs(\n        librosa.cqt(y=y_white, sr=sr_white, fmin=fmin, n_bins=n_bins, scale=scale)\n    )\n\n    if not scale:\n        freqs = librosa.cqt_frequencies(fmin=fmin, n_bins=n_bins)\n        lengths, _ = librosa.filters.wavelet_lengths(sr=sr_white, freqs=freqs)\n        C /= np.sqrt(lengths[:, np.newaxis])\n\n    assert np.allclose(np.mean(C, axis=1), 1.0, atol=2.5e-1), np.mean(C, axis=1)\n    assert np.allclose(np.std(C, axis=1), 0.5, atol=5e-1), np.std(C, axis=1)\n"
    },
    {
      "id": "librosa_librosa_236_1",
      "input_code": "def hybrid_cqt(\n    y: np.ndarray,\n    *,\n    sr: float = 22050,\n    hop_length: int = 512,\n    fmin: Optional[_FloatLike_co] = None,\n    n_bins: int = 84,\n    bins_per_octave: int = 12,\n    tuning: Optional[float] = 0.0,\n    filter_scale: float = 1,\n    norm: Optional[float] = 1,\n    sparsity: float = 0.01,\n    window: _WindowSpec = \"hann\",\n    scale: bool = True,\n    pad_mode: _PadMode = \"constant\",\n    res_type: str = \"soxr_hq\",\n    dtype: Optional[DTypeLike] = None,\n) -> np.ndarray:\n    \n    if fmin is None:\n        fmin = note_to_hz(\"C1\")\n\n    if tuning is None:\n        tuning = estimate_tuning(y=y, sr=sr, bins_per_octave=bins_per_octave)\n\n    fmin = fmin * 2.0 ** (tuning / bins_per_octave)\n\n    freqs = cqt_frequencies(n_bins, fmin=fmin, bins_per_octave=bins_per_octave)\n\n    if n_bins == 1:\n        alpha = __et_relative_bw(bins_per_octave)\n    else:\n        alpha = filters._relative_bandwidth(freqs=freqs)\n\n    lengths, _ = filters.wavelet_lengths(\n        freqs=freqs, sr=sr, filter_scale=filter_scale, window=window, alpha=alpha\n    )\n\n    pseudo_filters = 2.0 ** np.ceil(np.log2(lengths)) < 2 * hop_length\n\n    n_bins_pseudo = int(np.sum(pseudo_filters))\n\n    n_bins_full = n_bins - n_bins_pseudo\n    cqt_resp = []\n\n    if n_bins_pseudo > 0:\n        fmin_pseudo = np.min(freqs[pseudo_filters])\n\n        cqt_resp.append(\n            pseudo_cqt(\n                y,\n                sr=sr,\n                hop_length=hop_length,\n                fmin=fmin_pseudo,\n                n_bins=n_bins_pseudo,\n                bins_per_octave=bins_per_octave,\n                filter_scale=filter_scale,\n                norm=norm,\n                sparsity=sparsity,\n                window=window,\n                scale=scale,\n                pad_mode=pad_mode,\n                dtype=dtype,\n            )\n        )\n\n    if n_bins_full > 0:\n        cqt_resp.append(\n            np.abs(\n                cqt(\n                    y,\n                    sr=sr,\n                    hop_length=hop_length,\n                    fmin=fmin,\n                    n_bins=n_bins_full,\n                    bins_per_octave=bins_per_octave,\n                    filter_scale=filter_scale,\n                    norm=norm,\n                    sparsity=sparsity,\n                    window=window,\n                    scale=scale,\n                    pad_mode=pad_mode,\n                    res_type=res_type,\n                    dtype=dtype,\n                )\n            )\n        )\n\n    return __trim_stack(cqt_resp, n_bins, cqt_resp[-1].dtype)\n"
    },
    {
      "id": "librosa_librosa_236_5",
      "input_code": "def wavelet(\n    *,\n    freqs: np.ndarray,\n    sr: float = 22050,\n    window: _WindowSpec = \"hann\",\n    filter_scale: float = 1,\n    pad_fft: bool = True,\n    norm: Optional[float] = 1,\n    dtype: DTypeLike = np.complex64,\n    gamma: float = 0,\n    alpha: Optional[float] = None,\n    **kwargs: Any,\n) -> Tuple[np.ndarray, np.ndarray]:\n    \n    lengths, _ = wavelet_lengths(\n        freqs=freqs,\n        sr=sr,\n        window=window,\n        filter_scale=filter_scale,\n        gamma=gamma,\n        alpha=alpha,\n    )\n\n    filters = []\n    for ilen, freq in zip(lengths, freqs):\n        sig = util.phasor(\n            np.arange(-ilen // 2, ilen // 2, dtype=float) * 2 * np.pi * freq / sr\n        )\n\n        sig *= __float_window(window)(len(sig))\n\n        sig = util.normalize(sig, norm=norm)\n\n        filters.append(sig)\n\n    max_len = max(lengths)\n    if pad_fft:\n        max_len = int(2.0 ** (np.ceil(np.log2(max_len))))\n    else:\n        max_len = int(np.ceil(max_len))\n\n    filters = np.asarray(\n        [util.pad_center(filt, size=max_len, **kwargs) for filt in filters], dtype=dtype\n    )\n\n    return filters, lengths\n"
    },
    {
      "id": "librosa_librosa_236_2",
      "input_code": "def pseudo_cqt(\n    y: np.ndarray,\n    *,\n    sr: float = 22050,\n    hop_length: int = 512,\n    fmin: Optional[_FloatLike_co] = None,\n    n_bins: int = 84,\n    bins_per_octave: int = 12,\n    tuning: Optional[float] = 0.0,\n    filter_scale: float = 1,\n    norm: Optional[float] = 1,\n    sparsity: float = 0.01,\n    window: _WindowSpec = \"hann\",\n    scale: bool = True,\n    pad_mode: _PadMode = \"constant\",\n    dtype: Optional[DTypeLike] = None,\n) -> np.ndarray:\n    \n    if fmin is None:\n        fmin = note_to_hz(\"C1\")\n\n    if tuning is None:\n        tuning = estimate_tuning(y=y, sr=sr, bins_per_octave=bins_per_octave)\n\n    if dtype is None:\n        dtype = util.dtype_r2c(y.dtype)\n\n    fmin = fmin * 2.0 ** (tuning / bins_per_octave)\n\n    freqs = cqt_frequencies(fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave)\n\n    if n_bins == 1:\n        alpha = __et_relative_bw(bins_per_octave)\n    else:\n        alpha = filters._relative_bandwidth(freqs=freqs)\n\n    lengths, _ = filters.wavelet_lengths(\n        freqs=freqs, sr=sr, window=window, filter_scale=filter_scale, alpha=alpha\n    )\n\n    fft_basis, n_fft, _ = __vqt_filter_fft(\n        sr,\n        freqs,\n        filter_scale,\n        norm,\n        sparsity,\n        hop_length=hop_length,\n        window=window,\n        dtype=dtype,\n        alpha=alpha,\n    )\n\n    fft_basis = np.abs(fft_basis)\n\n    C: np.ndarray = __cqt_response(\n        y,\n        n_fft,\n        hop_length,\n        fft_basis,\n        pad_mode,\n        window=\"hann\",\n        dtype=dtype,\n        phase=False,\n    )\n\n    if scale:\n        C /= np.sqrt(n_fft)\n    else:\n        lengths = util.expand_to(lengths, ndim=C.ndim, axes=-2)\n\n        C *= np.sqrt(lengths / n_fft)\n\n    return C\n"
    },
    {
      "id": "librosa_librosa_236_9",
      "input_code": "def test_wavelet_lengths_badgamma():\n    librosa.filters.wavelet_lengths(freqs=2**np.arange(3), gamma=-1)\n"
    },
    {
      "id": "librosa_librosa_236_11",
      "input_code": "def test_wavelet_lengths_badfreqsorder():\n    librosa.filters.wavelet_lengths(freqs=2**np.arange(3)[::-1])\n"
    },
    {
      "id": "librosa_librosa_236_12",
      "input_code": "def test_wavelet_lengths_noalpha():\n    librosa.filters.wavelet_lengths(freqs=[64], alpha=None)\n"
    },
    {
      "id": "librosa_librosa_236_10",
      "input_code": "def test_wavelet_lengths_badfreqs():\n    librosa.filters.wavelet_lengths(freqs=2**np.arange(3) -20)\n"
    },
    {
      "id": "librosa_librosa_236_3",
      "input_code": "def icqt(\n    C: np.ndarray,\n    *,\n    sr: float = 22050,\n    hop_length: int = 512,\n    fmin: Optional[_FloatLike_co] = None,\n    bins_per_octave: int = 12,\n    tuning: float = 0.0,\n    filter_scale: float = 1,\n    norm: Optional[float] = 1,\n    sparsity: float = 0.01,\n    window: _WindowSpec = \"hann\",\n    scale: bool = True,\n    length: Optional[int] = None,\n    res_type: str = \"soxr_hq\",\n    dtype: Optional[DTypeLike] = None,\n) -> np.ndarray:\n    \n    if fmin is None:\n        fmin = note_to_hz(\"C1\")\n\n    fmin = fmin * 2.0 ** (tuning / bins_per_octave)\n\n    n_bins = C.shape[-2]\n\n    n_octaves = int(np.ceil(float(n_bins) / bins_per_octave))\n\n    freqs = cqt_frequencies(fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave)\n    if n_bins == 1:\n        alpha = __et_relative_bw(bins_per_octave)\n    else:\n        alpha = filters._relative_bandwidth(freqs=freqs)\n\n    lengths, f_cutoff = filters.wavelet_lengths(\n        freqs=freqs, sr=sr, window=window, filter_scale=filter_scale, alpha=alpha\n    )\n\n    if length is not None:\n        n_frames = int(np.ceil((length + max(lengths)) / hop_length))\n        C = C[..., :n_frames]\n\n    C_scale = np.sqrt(lengths)\n\n    y: Optional[np.ndarray] = None\n\n    srs = [sr]\n    hops = [hop_length]\n\n    for i in range(n_octaves - 1):\n        if hops[0] % 2 == 0:\n            srs.insert(0, srs[0] * 0.5)\n            hops.insert(0, hops[0] // 2)\n        else:\n            srs.insert(0, srs[0])\n            hops.insert(0, hops[0])\n\n    for i, (my_sr, my_hop) in enumerate(zip(srs, hops)):\n        n_filters = min(bins_per_octave, n_bins - bins_per_octave * i)\n\n        sl = slice(bins_per_octave * i, bins_per_octave * i + n_filters)\n\n        fft_basis, n_fft, _ = __vqt_filter_fft(\n            my_sr,\n            freqs[sl],\n            filter_scale,\n            norm,\n            sparsity,\n            window=window,\n            alpha=alpha[sl],\n        )\n\n        inv_basis = fft_basis.conjugate().T.todense()\n\n        freq_power = 1 / np.sum(util.abs2(np.asarray(inv_basis)), axis=0)\n\n        freq_power *= n_fft / lengths[sl]\n\n        if scale:\n            D_oct = np.einsum(\n                \"fc,c,c,...ct->...ft\",\n                inv_basis,\n                C_scale[sl],\n                freq_power,\n                C[..., sl, :],\n                optimize=True,\n            )\n        else:\n            D_oct = np.einsum(\n                \"fc,c,...ct->...ft\", inv_basis, freq_power, C[..., sl, :], optimize=True\n            )\n\n        y_oct = istft(D_oct, window=\"ones\", hop_length=my_hop, dtype=dtype)\n\n        y_oct = audio.resample(\n            y_oct,\n            orig_sr=1,\n            target_sr=sr // my_sr,\n            res_type=res_type,\n            scale=False,\n            fix=False,\n        )\n\n        if y is None:\n            y = y_oct\n        else:\n            y[..., : y_oct.shape[-1]] += y_oct\n    assert y is not None\n\n    if length:\n        y = util.fix_length(y, size=length)\n\n    return y\n"
    },
    {
      "id": "librosa_librosa_236_8",
      "input_code": "def test_wavelet_lengths_badscale():\n    librosa.filters.wavelet_lengths(freqs=2**np.arange(3), filter_scale=-1)\n"
    },
    {
      "id": "librosa_librosa_236_4",
      "input_code": "def vqt(\n    y: np.ndarray,\n    *,\n    sr: float = 22050,\n    hop_length: int = 512,\n    fmin: Optional[_FloatLike_co] = None,\n    n_bins: int = 84,\n    intervals: Union[str, Collection[float]] = \"equal\",\n    gamma: Optional[float] = None,\n    bins_per_octave: int = 12,\n    tuning: Optional[float] = 0.0,\n    filter_scale: float = 1,\n    norm: Optional[float] = 1,\n    sparsity: float = 0.01,\n    window: _WindowSpec = \"hann\",\n    scale: bool = True,\n    pad_mode: _PadMode = \"constant\",\n    res_type: Optional[str] = \"soxr_hq\",\n    dtype: Optional[DTypeLike] = None,\n) -> np.ndarray:\n    \n    if not isinstance(intervals, str):\n        bins_per_octave = len(intervals)\n\n    n_octaves = int(np.ceil(float(n_bins) / bins_per_octave))\n    n_filters = min(bins_per_octave, n_bins)\n\n    if fmin is None:\n        fmin = note_to_hz(\"C1\")\n\n    if tuning is None:\n        tuning = estimate_tuning(y=y, sr=sr, bins_per_octave=bins_per_octave)\n\n    if dtype is None:\n        dtype = util.dtype_r2c(y.dtype)\n\n    fmin = fmin * 2.0 ** (tuning / bins_per_octave)\n\n    freqs = interval_frequencies(\n        n_bins=n_bins,\n        fmin=fmin,\n        intervals=intervals,\n        bins_per_octave=bins_per_octave,\n        sort=True,\n    )\n\n    freqs_top = freqs[-bins_per_octave:]\n\n    fmax_t: float = np.max(freqs_top)\n    if n_bins == 1:\n        alpha = __et_relative_bw(bins_per_octave)\n    else:\n        alpha = filters._relative_bandwidth(freqs=freqs)\n\n    lengths, filter_cutoff = filters.wavelet_lengths(\n        freqs=freqs,\n        sr=sr,\n        window=window,\n        filter_scale=filter_scale,\n        gamma=gamma,\n        alpha=alpha,\n    )\n\n    nyquist = sr / 2.0\n\n    if filter_cutoff > nyquist:\n        raise ParameterError(\n            f\"Wavelet basis with max frequency={fmax_t} would exceed the Nyquist frequency={nyquist}. \"\n            \"Try reducing the number of frequency bins.\"\n        )\n\n    if res_type is None:\n        warnings.warn(\n            \"Support for VQT with res_type=None is deprecated in librosa 0.10\\n\"\n            \"and will be removed in version 1.0.\",\n            category=FutureWarning,\n            stacklevel=2,\n        )\n        res_type = \"soxr_hq\"\n\n    y, sr, hop_length = __early_downsample(\n        y, sr, hop_length, res_type, n_octaves, nyquist, filter_cutoff, scale\n    )\n\n    vqt_resp = []\n\n    my_y, my_sr, my_hop = y, sr, hop_length\n\n    for i in range(n_octaves):\n        if i == 0:\n            sl = slice(-n_filters, None)\n        else:\n            sl = slice(-n_filters * (i + 1), -n_filters * i)\n\n        freqs_oct = freqs[sl]\n        alpha_oct = alpha[sl]\n\n        fft_basis, n_fft, _ = __vqt_filter_fft(\n            my_sr,\n            freqs_oct,\n            filter_scale,\n            norm,\n            sparsity,\n            window=window,\n            gamma=gamma,\n            dtype=dtype,\n            alpha=alpha_oct,\n        )\n\n        fft_basis[:] *= np.sqrt(sr / my_sr)\n\n        vqt_resp.append(\n            __cqt_response(my_y, n_fft, my_hop, fft_basis, pad_mode, dtype=dtype)\n        )\n\n        if my_hop % 2 == 0:\n            my_hop //= 2\n            my_sr /= 2.0\n            my_y = audio.resample(\n                my_y, orig_sr=2, target_sr=1, res_type=res_type, scale=True\n            )\n\n    V = __trim_stack(vqt_resp, n_bins, dtype)\n\n    if scale:\n        lengths, _ = filters.wavelet_lengths(\n            freqs=freqs,\n            sr=sr,\n            window=window,\n            filter_scale=filter_scale,\n            gamma=gamma,\n            alpha=alpha,\n        )\n\n        lengths = util.expand_to(lengths, ndim=V.ndim, axes=-2)\n        V /= np.sqrt(lengths)\n\n    return V\n"
    },
    {
      "id": "librosa_librosa_236_7",
      "input_code": "def test_hybrid_cqt_white_noise(y_white, sr_white, fmin, n_bins, scale):\n    C = librosa.hybrid_cqt(\n        y=y_white, sr=sr_white, fmin=fmin, n_bins=n_bins, scale=scale\n    )\n\n    if not scale:\n        freqs = fmin * 2.0**(np.arange(n_bins) / 12)\n        lengths, _ = librosa.filters.wavelet_lengths(freqs=freqs, sr=sr_white)\n        C /= np.sqrt(lengths[:, np.newaxis])\n\n    assert np.allclose(np.mean(C, axis=1), 1.0, atol=2.5e-1), np.mean(C, axis=1)\n    assert np.allclose(np.std(C, axis=1), 0.5, atol=5e-1), np.std(C, axis=1)\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport numpy as np\n\n<testcase_1>\nfreqs = np.array([100, 200, 300, 400, 500])\nsr = 22050\nwindow = \"hann\"\nfilter_scale = 1\ngamma = 0\nalpha = None\n\n<testcase_2>\nfreqs = np.array([50, 100, 150, 200])\nsr = 44100\nwindow = \"blackman\"\nfilter_scale = 2\ngamma = 5\nalpha = np.array([0.1, 0.2, 0.3, 0.4])\n\n<testcase_3>\nfreqs = np.array([200, 400, 600, 800, 1000])\nsr = 16000\nwindow = \"hamming\"\nfilter_scale = 0.5\ngamma = None\nalpha = None\n\n<testcase_4>\nfreqs = np.array([250, 500, 750, 1000])\nsr = 48000\nwindow = \"bartlett\"\nfilter_scale = 1.5\ngamma = 10\nalpha = np.array([0.05, 0.1, 0.15, 0.2])\n\n<testcase_5>\nfreqs = np.array([300, 600, 900])\nsr = 32000\nwindow = \"kaiser\"\nfilter_scale = 0.8\ngamma = 2\nalpha = np.array([0.07, 0.14, 0.21])"
  ],
  "gpt_output": "<needimport>\nimport numpy as np\n\n<testcase_1>\nfreqs = np.array([100, 200, 300, 400, 500])\nsr = 22050\nwindow = \"hann\"\nfilter_scale = 1\ngamma = 0\nalpha = None\n\n<testcase_2>\nfreqs = np.array([50, 100, 150, 200])\nsr = 44100\nwindow = \"blackman\"\nfilter_scale = 2\ngamma = 5\nalpha = np.array([0.1, 0.2, 0.3, 0.4])\n\n<testcase_3>\nfreqs = np.array([200, 400, 600, 800, 1000])\nsr = 16000\nwindow = \"hamming\"\nfilter_scale = 0.5\ngamma = None\nalpha = None\n\n<testcase_4>\nfreqs = np.array([250, 500, 750, 1000])\nsr = 48000\nwindow = \"bartlett\"\nfilter_scale = 1.5\ngamma = 10\nalpha = np.array([0.05, 0.1, 0.15, 0.2])\n\n<testcase_5>\nfreqs = np.array([300, 600, 900])\nsr = 32000\nwindow = \"kaiser\"\nfilter_scale = 0.8\ngamma = 2\nalpha = np.array([0.07, 0.14, 0.21])",
  "needimport": "import numpy as np\n\n",
  "test_results": {
    "ans1": {
      "error": "unsupported operand type(s) for /: 'float' and 'list'",
      "traceback": "NoneType: None\n"
    },
    "ans2": {
      "lengths": [
        8820.0,
        3528.0,
        1764.0,
        1037.6470588235295
      ],
      "f_cutoff": 242.5
    },
    "ans3": {
      "error": "can't multiply sequence by non-int of type 'float'",
      "traceback": "NoneType: None\n"
    },
    "ans4": {
      "lengths": [
        3200.0,
        1200.0,
        587.7551020408164,
        342.85714285714283
      ],
      "f_cutoff": 1105.0
    },
    "ans5": {
      "lengths": [
        1113.0434782608697,
        297.6744186046512,
        134.03141361256544
      ],
      "f_cutoff": 1196.3125
    }
  }
}