{
  "input_header": "def _clear_plates(self):",
  "input_docstring": null,
  "output_code": "    def _clear_plates(self):\n        self._time_plate = None\n        self._region_plate = None",
  "input_contexts": [
    {
      "id": "pyro-ppl_pyro_649_1",
      "input_code": "    def __init__(self, compartments, duration, population, *, approximate=()):\n        super().__init__()\n\n        assert isinstance(duration, int)\n        assert duration >= 1\n        self.duration = duration\n\n        if isinstance(population, torch.Tensor):\n            assert population.dim() == 1\n            assert (population >= 1).all()\n            self.is_regional = True\n            self.max_plate_nesting = 2\n        else:\n            assert isinstance(population, int)\n            assert population >= 2\n            self.is_regional = False\n            self.max_plate_nesting = 1\n        self.population = population\n\n        compartments = tuple(compartments)\n        assert all(isinstance(name, str) for name in compartments)\n        assert len(compartments) == len(set(compartments))\n        self.compartments = compartments\n\n        assert isinstance(approximate, tuple)\n        assert all(name in compartments for name in approximate)\n        self.approximate = approximate\n\n        self.samples = {}\n        self._clear_plates()\n"
    },
    {
      "id": "pyro-ppl_pyro_649_2",
      "input_code": "    def _generative_model(self, forecast=0):\n        \n        params = self.global_model()\n\n        state = self.initialize(params)\n        state = {\n            k: v if isinstance(v, torch.Tensor) else torch.tensor(float(v))\n            for k, v in state.items()\n        }\n\n        for t in range(self.duration + forecast):\n            for name in self.approximate:\n                state[name + \"_approx\"] = state[name]\n            self.transition(params, state, t)\n            with self.region_plate:\n                for name in self.compartments:\n                    pyro.deterministic(\n                        \"{}_{}\".format(name, t), state[name], event_dim=0\n                    )\n\n        self._clear_plates()\n"
    },
    {
      "id": "pyro-ppl_pyro_649_4",
      "input_code": "    def _quantized_model(self):\n        \n        C = len(self.compartments)\n        T = self.duration\n        Q = self.num_quant_bins\n        R_shape = getattr(self.population, \"shape\", ())\n\n        params = self.global_model()\n        auxiliary, non_compartmental = self._sample_auxiliary()\n\n        curr, logp = quantize_enumerate(\n            auxiliary, min=0, max=self.population, num_quant_bins=self.num_quant_bins\n        )\n        curr = OrderedDict(zip(self.compartments, curr.unbind(0)))\n        logp = OrderedDict(zip(self.compartments, logp.unbind(0)))\n        curr.update(non_compartmental)\n\n        init = self.initialize(params)\n        prev = {}\n        for name, value in init.items():\n            if name in self.compartments:\n                if isinstance(value, torch.Tensor):\n                    value = value[..., None]\n                prev[name] = cat2(\n                    value, curr[name][:-1], dim=-3 if self.is_regional else -2\n                )\n            else:\n                prev[name] = cat2(init[name], curr[name][:-1], dim=-curr[name].dim())\n\n        def enum_reshape(tensor, position):\n            assert tensor.size(-1) == Q\n            assert tensor.dim() <= self.max_plate_nesting + 2\n            tensor = tensor.permute(tensor.dim() - 1, *range(tensor.dim() - 1))\n            shape = [Q] + [1] * (position + self.max_plate_nesting - (tensor.dim() - 2))\n            shape.extend(tensor.shape[1:])\n            return tensor.reshape(shape)\n\n        for e, name in enumerate(self.compartments):\n            curr[name] = enum_reshape(curr[name], e)\n            logp[name] = enum_reshape(logp[name], e)\n            prev[name] = enum_reshape(prev[name], e + C)\n\n        for name in self.approximate:\n            aux = auxiliary[self.compartments.index(name)]\n            curr[name + \"_approx\"] = aux\n            prev[name + \"_approx\"] = cat2(\n                init[name], aux[:-1], dim=-2 if self.is_regional else -1\n            )\n\n        with poutine.block(), poutine.trace() as tr:\n            with self.time_plate:\n                t = slice(0, T, 1)\n                self._transition_bwd(params, prev, curr, t)\n        tr.trace.compute_log_prob()\n        for name, site in tr.trace.nodes.items():\n            if site[\"type\"] == \"sample\":\n                log_prob = site[\"log_prob\"]\n                if log_prob.dim() <= self.max_plate_nesting:\n                    pyro.factor(\"transition_\" + name, site[\"log_prob_sum\"])\n                    continue\n                if self.is_regional and log_prob.shape[-1:] != R_shape:\n                    log_prob = (\n                        log_prob.expand(log_prob.shape[:-1] + R_shape) / R_shape[0]\n                    )\n                logp[name] = site[\"log_prob\"]\n\n        logp = reduce(operator.add, logp.values())\n        logp = logp.reshape(Q**C, Q**C, T, -1)\n        logp = logp.permute(3, 2, 0, 1).squeeze(0)\n        logp = pyro.distributions.hmm._sequential_logmatmulexp(\n            logp\n        )\n        logp = logp.reshape(-1, Q**C * Q**C).logsumexp(-1).sum()\n        warn_if_nan(logp)\n        pyro.factor(\"transition\", logp)\n\n        prev = {name: prev[name + \"_approx\"] for name in self.approximate}\n        curr = {name: curr[name + \"_approx\"] for name in self.approximate}\n        with _disallow_latent_variables(\".finalize()\"):\n            self.finalize(params, prev, curr)\n\n        self._clear_plates()\n"
    },
    {
      "id": "pyro-ppl_pyro_649_3",
      "input_code": "    def _sequential_model(self):\n        \n        C = len(self.compartments)\n        T = self.duration\n        R_shape = getattr(self.population, \"shape\", ())\n        num_samples = len(next(iter(self.samples.values())))\n\n        params = self.global_model()\n        auxiliary, non_compartmental = self._sample_auxiliary()\n\n        assert auxiliary.shape == (num_samples, C, T) + R_shape, (\n            auxiliary.shape,\n            (num_samples, C, T) + R_shape,\n        )\n        aux = [aux.unbind(2) for aux in auxiliary.unsqueeze(1).unbind(2)]\n\n        curr = self.initialize(params)\n        for t in poutine.markov(range(T)):\n            with self.region_plate:\n                prev, curr = curr, {}\n\n                for name, value in non_compartmental.items():\n                    curr[name] = value[:, t : t + 1]\n\n                for c, name in enumerate(self.compartments):\n                    curr[name] = quantize(\n                        \"{}_{}\".format(name, t),\n                        aux[c][t],\n                        min=0,\n                        max=self.population,\n                        num_quant_bins=self.num_quant_bins,\n                    )\n                    if name in self.approximate:\n                        curr[name + \"_approx\"] = aux[c][t]\n                        prev.setdefault(name + \"_approx\", prev[name])\n\n            self._transition_bwd(params, prev, curr, t)\n\n        self._clear_plates()\n"
    },
    {
      "id": "pyro-ppl_pyro_649_5",
      "input_code": "    def _relaxed_model(self):\n        \n        T = self.duration\n\n        params = self.global_model()\n        auxiliary, non_compartmental = self._sample_auxiliary()\n        particle_dims = auxiliary.dim() - (3 if self.is_regional else 2)\n        assert particle_dims in (0, 1)\n\n        curr = dict(zip(self.compartments, auxiliary.unbind(particle_dims)))\n        curr.update(non_compartmental)\n\n        prev = {}\n        for name, value in self.initialize(params).items():\n            dim = particle_dims - curr[name].dim()\n            t = (slice(None),) * particle_dims + (slice(0, -1),)\n            prev[name] = cat2(value, curr[name][t], dim=dim)\n\n        for name in self.approximate:\n            curr[name + \"_approx\"] = curr[name]\n            prev[name + \"_approx\"] = prev[name]\n\n        with self.time_plate:\n            t = slice(0, T, 1)\n            self._transition_bwd(params, prev, curr, t)\n\n        with _disallow_latent_variables(\".finalize()\"):\n            self.finalize(params, prev, curr)\n\n        self._clear_plates()\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport torch\n\n<testcase_1>\ncompartments = [\"compartment1\", \"compartment2\"]\nduration = 5\npopulation = torch.tensor([10, 20, 30])\napproximate = (\"compartment1\",)\nsamples = {\"sample1\": torch.tensor([1, 2, 3])}\n\n<testcase_2>\ncompartments = [\"compartmentA\", \"compartmentB\", \"compartmentC\"]\nduration = 10\npopulation = 100\napproximate = (\"compartmentA\", \"compartmentB\")\nsamples = {\"sampleA\": torch.tensor([4, 5, 6]), \"sampleB\": torch.tensor([7, 8, 9])}\n\n<testcase_3>\ncompartments = [\"compartmentX\", \"compartmentY\"]\nduration = 3\npopulation = torch.tensor([5, 15])\napproximate = (\"compartmentX\",)\nsamples = {\"sampleX\": torch.tensor([2, 4, 6])}\n\n<testcase_4>\ncompartments = [\"compartment1\", \"compartment2\", \"compartment3\"]\nduration = 7\npopulation = 50\napproximate = (\"compartment2\",)\nsamples = {\"sample1\": torch.tensor([1, 1, 1]), \"sample2\": torch.tensor([2, 2, 2])}\n\n<testcase_5>\ncompartments = [\"compartmentA\", \"compartmentB\"]\nduration = 4\npopulation = torch.tensor([8, 12, 16])\napproximate = (\"compartmentA\", \"compartmentB\")\nsamples = {\"sampleA\": torch.tensor([3, 6, 9]), \"sampleB\": torch.tensor([4, 8, 12])}"
  ],
  "gpt_output": "<needimport>\nimport torch\n\n<testcase_1>\ncompartments = [\"compartment1\", \"compartment2\"]\nduration = 5\npopulation = torch.tensor([10, 20, 30])\napproximate = (\"compartment1\",)\nsamples = {\"sample1\": torch.tensor([1, 2, 3])}\n\n<testcase_2>\ncompartments = [\"compartmentA\", \"compartmentB\", \"compartmentC\"]\nduration = 10\npopulation = 100\napproximate = (\"compartmentA\", \"compartmentB\")\nsamples = {\"sampleA\": torch.tensor([4, 5, 6]), \"sampleB\": torch.tensor([7, 8, 9])}\n\n<testcase_3>\ncompartments = [\"compartmentX\", \"compartmentY\"]\nduration = 3\npopulation = torch.tensor([5, 15])\napproximate = (\"compartmentX\",)\nsamples = {\"sampleX\": torch.tensor([2, 4, 6])}\n\n<testcase_4>\ncompartments = [\"compartment1\", \"compartment2\", \"compartment3\"]\nduration = 7\npopulation = 50\napproximate = (\"compartment2\",)\nsamples = {\"sample1\": torch.tensor([1, 1, 1]), \"sample2\": torch.tensor([2, 2, 2])}\n\n<testcase_5>\ncompartments = [\"compartmentA\", \"compartmentB\"]\nduration = 4\npopulation = torch.tensor([8, 12, 16])\napproximate = (\"compartmentA\", \"compartmentB\")\nsamples = {\"sampleA\": torch.tensor([3, 6, 9]), \"sampleB\": torch.tensor([4, 8, 12])}",
  "needimport": "import torch\n\n",
  "test_results": {
    "ans1": {
      "_time_plate": null,
      "_region_plate": null
    },
    "ans2": {
      "_time_plate": null,
      "_region_plate": null
    },
    "ans3": {
      "_time_plate": null,
      "_region_plate": null
    },
    "ans4": {
      "_time_plate": null,
      "_region_plate": null
    },
    "ans5": {
      "_time_plate": null,
      "_region_plate": null
    }
  }
}