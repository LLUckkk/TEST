{
  "input_header": "def _get_node_referenced_flow_inputs( node, flow_inputs: Dict[str, FlowInputDefinition] ) -> Dict[str, FlowInputDefinition]:",
  "input_docstring": null,
  "output_code": "    def _get_node_referenced_flow_inputs(\n        node, flow_inputs: Dict[str, FlowInputDefinition]\n    ) -> Dict[str, FlowInputDefinition]:\n        node_referenced_flow_inputs = {}\n        for _, value in node.inputs.items():\n            if value.value_type == InputValueType.FLOW_INPUT and value.value in flow_inputs:\n                node_referenced_flow_inputs[value.value] = flow_inputs[value.value]\n        return node_referenced_flow_inputs",
  "input_contexts": [
    {
      "id": "microsoft_promptflow_2675_1",
      "input_code": "    def load_and_exec_node(\n        cls,\n        flow_file: Path,\n        node_name: str,\n        *,\n        storage: AbstractRunStorage = None,\n        output_sub_dir: Optional[str] = None,\n        flow_inputs: Optional[Mapping[str, Any]] = None,\n        dependency_nodes_outputs: Optional[Mapping[str, Any]] = None,\n        connections: Optional[dict] = None,\n        working_dir: Optional[Path] = None,\n        raise_ex: bool = False,\n    ):\n        \n\n        @contextlib.contextmanager\n        def update_operation_context():\n            operation_context = OperationContext.get_instance()\n            original_context = operation_context.copy()\n            try:\n                append_promptflow_package_ua(operation_context)\n                operation_context.set_execution_target(cls._execution_target)\n                operation_context.set_default_tracing_keys(DEFAULT_TRACING_KEYS)\n                operation_context[\"run_mode\"] = RunMode.SingleNode.name\n                inject_openai_api()\n                yield\n            finally:\n                OperationContext.set_instance(original_context)\n\n        if threading.current_thread() is threading.main_thread():\n            signal.signal(signal.SIGINT, signal_handler)\n            signal.signal(signal.SIGTERM, signal_handler)\n\n        dependency_nodes_outputs = dependency_nodes_outputs or {}\n        working_dir = Flow._resolve_working_dir(flow_file, working_dir)\n        with open(working_dir / flow_file, \"r\") as fin:\n            flow = Flow.deserialize(load_yaml(fin))\n        node = flow.get_node(node_name)\n        if node is None:\n            raise SingleNodeValidationError(\n                message_format=(\n                    \"Validation failed when attempting to execute the node. \"\n                    \"Node '{node_name}' is not found in flow '{flow_file}'. \"\n                    \"Please change node name or correct the flow file.\"\n                ),\n                node_name=node_name,\n                flow_file=flow_file,\n            )\n        if not node.source or not node.type:\n            raise SingleNodeValidationError(\n                message_format=(\n                    \"Validation failed when attempting to execute the node. \"\n                    \"Properties 'source' or 'type' are not specified for Node '{node_name}' in flow '{flow_file}'. \"\n                    \"Please make sure these properties are in place and try again.\"\n                ),\n                node_name=node_name,\n                flow_file=flow_file,\n            )\n        node_referenced_flow_inputs = FlowExecutor._get_node_referenced_flow_inputs(node, flow.inputs)\n        inputs_with_default_value = apply_default_value_for_input(node_referenced_flow_inputs, flow_inputs)\n        converted_flow_inputs_for_node = FlowValidator.convert_flow_inputs_for_node(\n            flow, node, inputs_with_default_value\n        )\n\n        multimedia_processor = MultimediaProcessor.create(flow.message_format)\n        inputs = multimedia_processor.load_multimedia_data(node_referenced_flow_inputs, converted_flow_inputs_for_node)\n        dependency_nodes_outputs = multimedia_processor.load_multimedia_data_recursively(dependency_nodes_outputs)\n        package_tool_keys = [node.source.tool] if node.source and node.source.tool else []\n        if isinstance(connections, dict):\n            connections = DictConnectionProvider(connections)\n        tool_resolver = ToolResolver(working_dir, connections, package_tool_keys, message_format=flow.message_format)\n        resolved_node = tool_resolver.resolve_tool_by_node(node)\n\n\n        resolved_inputs = {}\n        for k, v in resolved_node.node.inputs.items():\n            value = _input_assignment_parser.parse_value(v, dependency_nodes_outputs, inputs)\n            resolved_inputs[k] = value\n            if resolved_node.node.aggregation:\n                if (\n                    v.value_type == InputValueType.FLOW_INPUT\n                    or v.value_type == InputValueType.NODE_REFERENCE\n                    and flow.is_normal_node(v.value)\n                ):\n                    resolved_inputs[k] = [value]\n\n        resolved_inputs = {k: v for k, v in resolved_inputs.items() if k not in resolved_node.init_args}\n\n        if storage is None:\n            sub_dir = \".\" if output_sub_dir is None else output_sub_dir\n            storage = DefaultRunStorage(base_dir=working_dir, sub_dir=Path(sub_dir))\n\n        run_tracker = RunTracker(storage)\n        with run_tracker.node_log_manager, update_operation_context():\n            context = FlowExecutionContext(\n                name=flow.name,\n                run_tracker=run_tracker,\n                cache_manager=AbstractCacheManager.init_from_env(),\n                message_format=flow.message_format,\n            )\n\n            try:\n                if inspect.iscoroutinefunction(resolved_node.callable):\n                    asyncio.run(\n                        context.invoke_tool_async(resolved_node.node, resolved_node.callable, kwargs=resolved_inputs),\n                    )\n                else:\n                    context.invoke_tool(resolved_node.node, resolved_node.callable, kwargs=resolved_inputs)\n            except KeyboardInterrupt:\n                run_tracker.cancel_node_runs()\n            except Exception:\n                if raise_ex:\n                    raise\n\n            node_runs = run_tracker.collect_node_runs()\n            if len(node_runs) != 1:\n                raise UnexpectedError(\n                    message_format=(\n                        \"Single node execution failed. Expected one node result, \"\n                        \"but received {node_result_num}. Please contact support for further assistance.\"\n                    ),\n                    node_result_num=len(node_runs),\n                )\n            return node_runs[0]\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport typing\nfrom typing import Dict\nfrom enum import Enum\n\nclass InputValueType(Enum):\n    FLOW_INPUT = \"flow_input\"\n    NODE_REFERENCE = \"node_reference\"\n\nclass FlowInputDefinition:\n    def __init__(self, name: str, value_type: InputValueType):\n        self.name = name\n        self.value_type = value_type\n\nclass NodeInput:\n    def __init__(self, value_type: InputValueType, value: str):\n        self.value_type = value_type\n        self.value = value\n\nclass Node:\n    def __init__(self, inputs: Dict[str, NodeInput]):\n        self.inputs = inputs\n\n<testcase_1>\nflow_inputs = {\n    \"input1\": FlowInputDefinition(name=\"input1\", value_type=InputValueType.FLOW_INPUT),\n    \"input2\": FlowInputDefinition(name=\"input2\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"input1\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"input1\"),\n    \"input2\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"input2\"),\n}\nnode = Node(inputs=node_inputs)\n\n<testcase_2>\nflow_inputs = {\n    \"inputA\": FlowInputDefinition(name=\"inputA\", value_type=InputValueType.FLOW_INPUT),\n    \"inputB\": FlowInputDefinition(name=\"inputB\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"inputA\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"inputA\"),\n    \"inputB\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"inputB\"),\n}\nnode = Node(inputs=node_inputs)\n\n<testcase_3>\nflow_inputs = {\n    \"data1\": FlowInputDefinition(name=\"data1\", value_type=InputValueType.FLOW_INPUT),\n    \"data2\": FlowInputDefinition(name=\"data2\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"data1\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"data1\"),\n    \"data2\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"data2\"),\n}\nnode = Node(inputs=node_inputs)\n\n<testcase_4>\nflow_inputs = {\n    \"param1\": FlowInputDefinition(name=\"param1\", value_type=InputValueType.FLOW_INPUT),\n    \"param2\": FlowInputDefinition(name=\"param2\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"param1\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"param1\"),\n    \"param2\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"param2\"),\n}\nnode = Node(inputs=node_inputs)\n\n<testcase_5>\nflow_inputs = {\n    \"inputX\": FlowInputDefinition(name=\"inputX\", value_type=InputValueType.FLOW_INPUT),\n    \"inputY\": FlowInputDefinition(name=\"inputY\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"inputX\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"inputX\"),\n    \"inputY\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"inputY\"),\n}\nnode = Node(inputs=node_inputs)"
  ],
  "gpt_output": "<needimport>\nimport typing\nfrom typing import Dict\nfrom enum import Enum\n\nclass InputValueType(Enum):\n    FLOW_INPUT = \"flow_input\"\n    NODE_REFERENCE = \"node_reference\"\n\nclass FlowInputDefinition:\n    def __init__(self, name: str, value_type: InputValueType):\n        self.name = name\n        self.value_type = value_type\n\nclass NodeInput:\n    def __init__(self, value_type: InputValueType, value: str):\n        self.value_type = value_type\n        self.value = value\n\nclass Node:\n    def __init__(self, inputs: Dict[str, NodeInput]):\n        self.inputs = inputs\n\n<testcase_1>\nflow_inputs = {\n    \"input1\": FlowInputDefinition(name=\"input1\", value_type=InputValueType.FLOW_INPUT),\n    \"input2\": FlowInputDefinition(name=\"input2\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"input1\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"input1\"),\n    \"input2\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"input2\"),\n}\nnode = Node(inputs=node_inputs)\n\n<testcase_2>\nflow_inputs = {\n    \"inputA\": FlowInputDefinition(name=\"inputA\", value_type=InputValueType.FLOW_INPUT),\n    \"inputB\": FlowInputDefinition(name=\"inputB\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"inputA\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"inputA\"),\n    \"inputB\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"inputB\"),\n}\nnode = Node(inputs=node_inputs)\n\n<testcase_3>\nflow_inputs = {\n    \"data1\": FlowInputDefinition(name=\"data1\", value_type=InputValueType.FLOW_INPUT),\n    \"data2\": FlowInputDefinition(name=\"data2\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"data1\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"data1\"),\n    \"data2\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"data2\"),\n}\nnode = Node(inputs=node_inputs)\n\n<testcase_4>\nflow_inputs = {\n    \"param1\": FlowInputDefinition(name=\"param1\", value_type=InputValueType.FLOW_INPUT),\n    \"param2\": FlowInputDefinition(name=\"param2\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"param1\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"param1\"),\n    \"param2\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"param2\"),\n}\nnode = Node(inputs=node_inputs)\n\n<testcase_5>\nflow_inputs = {\n    \"inputX\": FlowInputDefinition(name=\"inputX\", value_type=InputValueType.FLOW_INPUT),\n    \"inputY\": FlowInputDefinition(name=\"inputY\", value_type=InputValueType.FLOW_INPUT),\n}\nnode_inputs = {\n    \"inputX\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"inputX\"),\n    \"inputY\": NodeInput(value_type=InputValueType.FLOW_INPUT, value=\"inputY\"),\n}\nnode = Node(inputs=node_inputs)",
  "needimport": "import typing\nfrom typing import Dict\nfrom enum import Enum\n\nclass InputValueType(Enum):\n    FLOW_INPUT = \"flow_input\"\n    NODE_REFERENCE = \"node_reference\"\n\nclass FlowInputDefinition:\n    def __init__(self, name: str, value_type: InputValueType):\n        self.name = name\n        self.value_type = value_type\n\nclass NodeInput:\n    def __init__(self, value_type: InputValueType, value: str):\n        self.value_type = value_type\n        self.value = value\n\nclass Node:\n    def __init__(self, inputs: Dict[str, NodeInput]):\n        self.inputs = inputs\n\n",
  "test_results": {
    "ans1": {
      "input1": {
        "name": "input1",
        "value_type": "flow_input"
      },
      "input2": {
        "name": "input2",
        "value_type": "flow_input"
      }
    },
    "ans2": {
      "inputA": {
        "name": "inputA",
        "value_type": "flow_input"
      },
      "inputB": {
        "name": "inputB",
        "value_type": "flow_input"
      }
    },
    "ans3": {
      "data1": {
        "name": "data1",
        "value_type": "flow_input"
      },
      "data2": {
        "name": "data2",
        "value_type": "flow_input"
      }
    },
    "ans4": {
      "param1": {
        "name": "param1",
        "value_type": "flow_input"
      },
      "param2": {
        "name": "param2",
        "value_type": "flow_input"
      }
    },
    "ans5": {
      "inputX": {
        "name": "inputX",
        "value_type": "flow_input"
      },
      "inputY": {
        "name": "inputY",
        "value_type": "flow_input"
      }
    }
  }
}