{
  "input_header": "def build_err_msg(arrays, err_msg, header='Items are not equal:', verbose=True, names=('ACTUAL', 'DESIRED'), precision=8):",
  "input_docstring": null,
  "output_code": "def build_err_msg(arrays, err_msg, header='Items are not equal:',\n                  verbose=True, names=('ACTUAL', 'DESIRED'), precision=8):\n    msg = ['\\n' + header]\n    if err_msg:\n        if err_msg.find('\\n') == -1 and len(err_msg) < 79-len(header):\n            msg = [msg[0] + ' ' + err_msg]\n        else:\n            msg.append(err_msg)\n    if verbose:\n        for i, a in enumerate(arrays):\n\n            if isinstance(a, ndarray):\n                r_func = partial(array_repr, precision=precision)\n            else:\n                r_func = repr\n\n            try:\n                r = r_func(a)\n            except Exception as exc:\n                r = f'[repr failed for <{type(a).__name__}>: {exc}]'\n            if r.count('\\n') > 3:\n                r = '\\n'.join(r.splitlines()[:3])\n                r += '...'\n            msg.append(f' {names[i]}: {r}')\n    return '\\n'.join(msg)",
  "input_contexts": [
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_5",
      "input_code": "    def assert_array_compare(self, comparison, x, y, err_msg='', header='',\n                         fill_value=True):\n        \n        xf = self.filled(x)\n        yf = self.filled(y)\n        m = self.mask_or(self.getmask(x), self.getmask(y))\n\n        x = self.filled(self.masked_array(xf, mask=m), fill_value)\n        y = self.filled(self.masked_array(yf, mask=m), fill_value)\n        if (x.dtype.char != \"O\"):\n            x = x.astype(float_)\n            if isinstance(x, np.ndarray) and x.size > 1:\n                x[np.isnan(x)] = 0\n            elif np.isnan(x):\n                x = 0\n        if (y.dtype.char != \"O\"):\n            y = y.astype(float_)\n            if isinstance(y, np.ndarray) and y.size > 1:\n                y[np.isnan(y)] = 0\n            elif np.isnan(y):\n                y = 0\n        try:\n            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape\n            if not cond:\n                msg = build_err_msg([x, y],\n                                    err_msg\n                                    + f'\\n(shapes {x.shape}, {y.shape} mismatch)',\n                                    header=header,\n                                    names=('x', 'y'))\n                assert cond, msg\n            val = comparison(x, y)\n            if m is not self.nomask and fill_value:\n                val = self.masked_array(val, mask=m)\n            if isinstance(val, bool):\n                cond = val\n                reduced = [0]\n            else:\n                reduced = val.ravel()\n                cond = reduced.all()\n                reduced = reduced.tolist()\n            if not cond:\n                match = 100-100.0*reduced.count(1)/len(reduced)\n                msg = build_err_msg([x, y],\n                                    err_msg\n                                    + '\\n(mismatch %s%%)' % (match,),\n                                    header=header,\n                                    names=('x', 'y'))\n                assert cond, msg\n        except ValueError as e:\n            msg = build_err_msg([x, y], err_msg, header=header, names=('x', 'y'))\n            raise ValueError(msg) from e\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_7",
      "input_code": "def assert_almost_equal(actual,desired,decimal=7,err_msg='',verbose=True):\n    \n    __tracebackhide__ = True\n    from numpy.core import ndarray\n    from numpy.lib import iscomplexobj, real, imag\n\n    try:\n        usecomplex = iscomplexobj(actual) or iscomplexobj(desired)\n    except ValueError:\n        usecomplex = False\n\n    def _build_err_msg():\n        header = ('Arrays are not almost equal to %d decimals' % decimal)\n        return build_err_msg([actual, desired], err_msg, verbose=verbose,\n                             header=header)\n\n    if usecomplex:\n        if iscomplexobj(actual):\n            actualr = real(actual)\n            actuali = imag(actual)\n        else:\n            actualr = actual\n            actuali = 0\n        if iscomplexobj(desired):\n            desiredr = real(desired)\n            desiredi = imag(desired)\n        else:\n            desiredr = desired\n            desiredi = 0\n        try:\n            assert_almost_equal(actualr, desiredr, decimal=decimal)\n            assert_almost_equal(actuali, desiredi, decimal=decimal)\n        except AssertionError:\n            raise AssertionError(_build_err_msg())\n\n    if isinstance(actual, (ndarray, tuple, list)) \\\n            or isinstance(desired, (ndarray, tuple, list)):\n        return assert_array_almost_equal(actual, desired, decimal, err_msg)\n    try:\n        if not (gisfinite(desired) and gisfinite(actual)):\n            if gisnan(desired) or gisnan(actual):\n                if not (gisnan(desired) and gisnan(actual)):\n                    raise AssertionError(_build_err_msg())\n            else:\n                if not desired == actual:\n                    raise AssertionError(_build_err_msg())\n            return\n    except (NotImplementedError, TypeError):\n        pass\n    if abs(desired - actual) >= np.float64(1.5 * 10.0**(-decimal)):\n        raise AssertionError(_build_err_msg())\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_11",
      "input_code": "    def test_build_err_msg_no_verbose(self):\n        x = np.array([1.00001, 2.00002, 3.00003])\n        y = np.array([1.00002, 2.00003, 3.00004])\n        err_msg = 'There is a mismatch'\n\n        a = build_err_msg([x, y], err_msg, verbose=False)\n        b = '\\nItems are not equal: There is a mismatch'\n        assert_equal(a, b)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_12",
      "input_code": "    def test_build_err_msg_custom_names(self):\n        x = np.array([1.00001, 2.00002, 3.00003])\n        y = np.array([1.00002, 2.00003, 3.00004])\n        err_msg = 'There is a mismatch'\n\n        a = build_err_msg([x, y], err_msg, names=('FOO', 'BAR'))\n        b = ('\\nItems are not equal: There is a mismatch\\n FOO: array(['\n             '1.00001, 2.00002, 3.00003])\\n BAR: array([1.00002, 2.00003, '\n             '3.00004])')\n        assert_equal(a, b)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_9",
      "input_code": "def assert_array_compare(comparison, x, y, err_msg='', verbose=True, header='',\n                         precision=6, equal_nan=True, equal_inf=True,\n                         *, strict=False):\n    __tracebackhide__ = True\n    from numpy.core import array, array2string, isnan, inf, bool_, errstate, all, max, object_\n\n    x = np.asanyarray(x)\n    y = np.asanyarray(y)\n\n    ox, oy = x, y\n\n    def isnumber(x):\n        return x.dtype.char in '?bhilqpBHILQPefdgFDG'\n\n    def istime(x):\n        return x.dtype.char in \"Mm\"\n\n    def func_assert_same_pos(x, y, func=isnan, hasval='nan'):\n        \n        __tracebackhide__ = True\n\n        x_id = func(x)\n        y_id = func(y)\n        if bool_(x_id == y_id).all() != True:\n            msg = build_err_msg([x, y],\n                                err_msg + '\\nx and y %s location mismatch:'\n                                % (hasval), verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n            raise AssertionError(msg)\n        if isinstance(x_id, bool) or x_id.ndim == 0:\n            return bool_(x_id)\n        elif isinstance(y_id, bool) or y_id.ndim == 0:\n            return bool_(y_id)\n        else:\n            return y_id\n\n    try:\n        if strict:\n            cond = x.shape == y.shape and x.dtype == y.dtype\n        else:\n            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape\n        if not cond:\n            if x.shape != y.shape:\n                reason = f'\\n(shapes {x.shape}, {y.shape} mismatch)'\n            else:\n                reason = f'\\n(dtypes {x.dtype}, {y.dtype} mismatch)'\n            msg = build_err_msg([x, y],\n                                err_msg\n                                + reason,\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n            raise AssertionError(msg)\n\n        flagged = bool_(False)\n        if isnumber(x) and isnumber(y):\n            if equal_nan:\n                flagged = func_assert_same_pos(x, y, func=isnan, hasval='nan')\n\n            if equal_inf:\n                flagged |= func_assert_same_pos(x, y,\n                                                func=lambda xy: xy == +inf,\n                                                hasval='+inf')\n                flagged |= func_assert_same_pos(x, y,\n                                                func=lambda xy: xy == -inf,\n                                                hasval='-inf')\n\n        elif istime(x) and istime(y):\n            if equal_nan and x.dtype.type == y.dtype.type:\n                flagged = func_assert_same_pos(x, y, func=isnat, hasval=\"NaT\")\n\n        if flagged.ndim > 0:\n            x, y = x[~flagged], y[~flagged]\n            if x.size == 0:\n                return\n        elif flagged:\n            return\n\n        val = comparison(x, y)\n\n        if isinstance(val, bool):\n            cond = val\n            reduced = array([val])\n        else:\n            reduced = val.ravel()\n            cond = reduced.all()\n\n        if cond != True:\n            n_mismatch = reduced.size - reduced.sum(dtype=intp)\n            n_elements = flagged.size if flagged.ndim != 0 else reduced.size\n            percent_mismatch = 100 * n_mismatch / n_elements\n            remarks = [\n                'Mismatched elements: {} / {} ({:.3g}%)'.format(\n                    n_mismatch, n_elements, percent_mismatch)]\n\n            with errstate(all='ignore'):\n                with contextlib.suppress(TypeError):\n                    error = abs(x - y)\n                    if np.issubdtype(x.dtype, np.unsignedinteger):\n                        error2 = abs(y - x)\n                        np.minimum(error, error2, out=error)\n                    max_abs_error = max(error)\n                    if getattr(error, 'dtype', object_) == object_:\n                        remarks.append('Max absolute difference: '\n                                        + str(max_abs_error))\n                    else:\n                        remarks.append('Max absolute difference: '\n                                        + array2string(max_abs_error))\n\n                    nonzero = bool_(y != 0)\n                    if all(~nonzero):\n                        max_rel_error = array(inf)\n                    else:\n                        max_rel_error = max(error[nonzero] / abs(y[nonzero]))\n                    if getattr(error, 'dtype', object_) == object_:\n                        remarks.append('Max relative difference: '\n                                        + str(max_rel_error))\n                    else:\n                        remarks.append('Max relative difference: '\n                                        + array2string(max_rel_error))\n\n            err_msg += '\\n' + '\\n'.join(remarks)\n            msg = build_err_msg([ox, oy], err_msg,\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n            raise AssertionError(msg)\n    except ValueError:\n        import traceback\n        efmt = traceback.format_exc()\n        header = f'error during assertion:\\n\\n{efmt}\\n\\n{header}'\n\n        msg = build_err_msg([x, y], err_msg, verbose=verbose, header=header,\n                            names=('x', 'y'), precision=precision)\n        raise ValueError(msg)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_6",
      "input_code": "def assert_equal(actual, desired, err_msg='', verbose=True):\n    \n    __tracebackhide__ = True\n    if isinstance(desired, dict):\n        if not isinstance(actual, dict):\n            raise AssertionError(repr(type(actual)))\n        assert_equal(len(actual), len(desired), err_msg, verbose)\n        for k, i in desired.items():\n            if k not in actual:\n                raise AssertionError(repr(k))\n            assert_equal(actual[k], desired[k], f'key={k!r}\\n{err_msg}',\n                         verbose)\n        return\n    if isinstance(desired, (list, tuple)) and isinstance(actual, (list, tuple)):\n        assert_equal(len(actual), len(desired), err_msg, verbose)\n        for k in range(len(desired)):\n            assert_equal(actual[k], desired[k], f'item={k!r}\\n{err_msg}',\n                         verbose)\n        return\n    from numpy.core import ndarray, isscalar, signbit\n    from numpy.lib import iscomplexobj, real, imag\n    if isinstance(actual, ndarray) or isinstance(desired, ndarray):\n        return assert_array_equal(actual, desired, err_msg, verbose)\n    msg = build_err_msg([actual, desired], err_msg, verbose=verbose)\n\n    try:\n        usecomplex = iscomplexobj(actual) or iscomplexobj(desired)\n    except (ValueError, TypeError):\n        usecomplex = False\n\n    if usecomplex:\n        if iscomplexobj(actual):\n            actualr = real(actual)\n            actuali = imag(actual)\n        else:\n            actualr = actual\n            actuali = 0\n        if iscomplexobj(desired):\n            desiredr = real(desired)\n            desiredi = imag(desired)\n        else:\n            desiredr = desired\n            desiredi = 0\n        try:\n            assert_equal(actualr, desiredr)\n            assert_equal(actuali, desiredi)\n        except AssertionError:\n            raise AssertionError(msg)\n\n    if isscalar(desired) != isscalar(actual):\n        raise AssertionError(msg)\n\n    try:\n        isdesnat = isnat(desired)\n        isactnat = isnat(actual)\n        dtypes_match = (np.asarray(desired).dtype.type ==\n                        np.asarray(actual).dtype.type)\n        if isdesnat and isactnat:\n            if dtypes_match:\n                return\n            else:\n                raise AssertionError(msg)\n\n    except (TypeError, ValueError, NotImplementedError):\n        pass\n\n    try:\n        isdesnan = gisnan(desired)\n        isactnan = gisnan(actual)\n        if isdesnan and isactnan:\n            return\n\n        array_actual = np.asarray(actual)\n        array_desired = np.asarray(desired)\n        if (array_actual.dtype.char in 'Mm' or\n                array_desired.dtype.char in 'Mm'):\n            raise NotImplementedError('cannot compare to a scalar '\n                                      'with a different type')\n\n        if desired == 0 and actual == 0:\n            if not signbit(desired) == signbit(actual):\n                raise AssertionError(msg)\n\n    except (TypeError, ValueError, NotImplementedError):\n        pass\n\n    try:\n        if not (desired == actual):\n            raise AssertionError(msg)\n\n    except (DeprecationWarning, FutureWarning) as e:\n        if 'elementwise == comparison' in e.args[0]:\n            raise AssertionError(msg)\n        else:\n            raise\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_3",
      "input_code": "def assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True):\n    \n    if isinstance(actual, np.ndarray) or isinstance(desired, np.ndarray):\n        return assert_array_almost_equal(actual, desired, decimal=decimal,\n                                         err_msg=err_msg, verbose=verbose)\n    msg = build_err_msg([actual, desired],\n                        err_msg=err_msg, verbose=verbose)\n    if not round(abs(desired - actual), decimal) == 0:\n        raise AssertionError(msg)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_4",
      "input_code": "def assert_array_compare(comparison, x, y, err_msg='', verbose=True, header='',\n                         fill_value=True):\n    \n    m = mask_or(getmask(x), getmask(y))\n    x = masked_array(x, copy=False, mask=m, keep_mask=False, subok=False)\n    y = masked_array(y, copy=False, mask=m, keep_mask=False, subok=False)\n    if ((x is masked) and not (y is masked)) or \\\n            ((y is masked) and not (x is masked)):\n        msg = build_err_msg([x, y], err_msg=err_msg, verbose=verbose,\n                            header=header, names=('x', 'y'))\n        raise ValueError(msg)\n    return np.testing.assert_array_compare(comparison,\n                                           x.filled(fill_value),\n                                           y.filled(fill_value),\n                                           err_msg=err_msg,\n                                           verbose=verbose, header=header)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_2",
      "input_code": "def fail_if_equal(actual, desired, err_msg='',):\n    \n    if isinstance(desired, dict):\n        if not isinstance(actual, dict):\n            raise AssertionError(repr(type(actual)))\n        fail_if_equal(len(actual), len(desired), err_msg)\n        for k, i in desired.items():\n            if k not in actual:\n                raise AssertionError(repr(k))\n            fail_if_equal(actual[k], desired[k], f'key={k!r}\\n{err_msg}')\n        return\n    if isinstance(desired, (list, tuple)) and isinstance(actual, (list, tuple)):\n        fail_if_equal(len(actual), len(desired), err_msg)\n        for k in range(len(desired)):\n            fail_if_equal(actual[k], desired[k], f'item={k!r}\\n{err_msg}')\n        return\n    if isinstance(actual, np.ndarray) or isinstance(desired, np.ndarray):\n        return fail_if_array_equal(actual, desired, err_msg)\n    msg = build_err_msg([actual, desired], err_msg)\n    if not desired != actual:\n        raise AssertionError(msg)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_1",
      "input_code": "def assert_equal(actual, desired, err_msg=''):\n    \n    if isinstance(desired, dict):\n        if not isinstance(actual, dict):\n            raise AssertionError(repr(type(actual)))\n        assert_equal(len(actual), len(desired), err_msg)\n        for k, i in desired.items():\n            if k not in actual:\n                raise AssertionError(f\"{k} not in {actual}\")\n            assert_equal(actual[k], desired[k], f'key={k!r}\\n{err_msg}')\n        return\n    if isinstance(desired, (list, tuple)) and isinstance(actual, (list, tuple)):\n        return _assert_equal_on_sequences(actual, desired, err_msg='')\n    if not (isinstance(actual, ndarray) or isinstance(desired, ndarray)):\n        msg = build_err_msg([actual, desired], err_msg,)\n        if not desired == actual:\n            raise AssertionError(msg)\n        return\n    if ((actual is masked) and not (desired is masked)) or \\\n            ((desired is masked) and not (actual is masked)):\n        msg = build_err_msg([actual, desired],\n                            err_msg, header='', names=('x', 'y'))\n        raise ValueError(msg)\n    actual = np.asanyarray(actual)\n    desired = np.asanyarray(desired)\n    (actual_dtype, desired_dtype) = (actual.dtype, desired.dtype)\n    if actual_dtype.char == \"S\" and desired_dtype.char == \"S\":\n        return _assert_equal_on_sequences(actual.tolist(),\n                                          desired.tolist(),\n                                          err_msg='')\n    return assert_array_equal(actual, desired, err_msg)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_13",
      "input_code": "    def test_build_err_msg_custom_precision(self):\n        x = np.array([1.000000001, 2.00002, 3.00003])\n        y = np.array([1.000000002, 2.00003, 3.00004])\n        err_msg = 'There is a mismatch'\n\n        a = build_err_msg([x, y], err_msg, precision=10)\n        b = ('\\nItems are not equal: There is a mismatch\\n ACTUAL: array(['\n             '1.000000001, 2.00002    , 3.00003    ])\\n DESIRED: array(['\n             '1.000000002, 2.00003    , 3.00004    ])')\n        assert_equal(a, b)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_8",
      "input_code": "def assert_approx_equal(actual,desired,significant=7,err_msg='',verbose=True):\n    \n    __tracebackhide__ = True\n    import numpy as np\n\n    (actual, desired) = map(float, (actual, desired))\n    if desired == actual:\n        return\n    with np.errstate(invalid='ignore'):\n        scale = 0.5*(np.abs(desired) + np.abs(actual))\n        scale = np.power(10, np.floor(np.log10(scale)))\n    try:\n        sc_desired = desired/scale\n    except ZeroDivisionError:\n        sc_desired = 0.0\n    try:\n        sc_actual = actual/scale\n    except ZeroDivisionError:\n        sc_actual = 0.0\n    msg = build_err_msg(\n        [actual, desired], err_msg,\n        header='Items are not equal to %d significant digits:' % significant,\n        verbose=verbose)\n    try:\n        if not (gisfinite(desired) and gisfinite(actual)):\n            if gisnan(desired) or gisnan(actual):\n                if not (gisnan(desired) and gisnan(actual)):\n                    raise AssertionError(msg)\n            else:\n                if not desired == actual:\n                    raise AssertionError(msg)\n            return\n    except (TypeError, NotImplementedError):\n        pass\n    if np.abs(sc_desired - sc_actual) >= np.power(10., -(significant-1)):\n        raise AssertionError(msg)\n"
    },
    {
      "id": "krishnaik06_The-Grand-Complete-Data-Science-Materials_53495_10",
      "input_code": "    def test_build_err_msg_defaults(self):\n        x = np.array([1.00001, 2.00002, 3.00003])\n        y = np.array([1.00002, 2.00003, 3.00004])\n        err_msg = 'There is a mismatch'\n\n        a = build_err_msg([x, y], err_msg)\n        b = ('\\nItems are not equal: There is a mismatch\\n ACTUAL: array(['\n             '1.00001, 2.00002, 3.00003])\\n DESIRED: array([1.00002, '\n             '2.00003, 3.00004])')\n        assert_equal(a, b)\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport numpy as np\nfrom numpy import array\n\n<testcase_1>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'There is a mismatch'\nheader = 'Items are not equal:'\nverbose = True\nnames = ('ACTUAL', 'DESIRED')\nprecision = 8\n\n<testcase_2>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'There is a mismatch'\nheader = 'Comparison failed:'\nverbose = False\nnames = ('ACTUAL', 'DESIRED')\nprecision = 8\n\n<testcase_3>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'There is a mismatch'\nheader = 'Items are not equal:'\nverbose = True\nnames = ('FOO', 'BAR')\nprecision = 10\n\n<testcase_4>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'Mismatch detected'\nheader = 'Comparison failed:'\nverbose = True\nnames = ('ACTUAL', 'EXPECTED')\nprecision = 6\n\n<testcase_5>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'Arrays do not match'\nheader = 'Items are not equal:'\nverbose = True\nnames = ('ACTUAL', 'DESIRED')\nprecision = 8"
  ],
  "gpt_output": "<needimport>\nimport numpy as np\nfrom numpy import array\n\n<testcase_1>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'There is a mismatch'\nheader = 'Items are not equal:'\nverbose = True\nnames = ('ACTUAL', 'DESIRED')\nprecision = 8\n\n<testcase_2>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'There is a mismatch'\nheader = 'Comparison failed:'\nverbose = False\nnames = ('ACTUAL', 'DESIRED')\nprecision = 8\n\n<testcase_3>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'There is a mismatch'\nheader = 'Items are not equal:'\nverbose = True\nnames = ('FOO', 'BAR')\nprecision = 10\n\n<testcase_4>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'Mismatch detected'\nheader = 'Comparison failed:'\nverbose = True\nnames = ('ACTUAL', 'EXPECTED')\nprecision = 6\n\n<testcase_5>\narrays = [np.array([1.00001, 2.00002, 3.00003]), np.array([1.00002, 2.00003, 3.00004])]\nerr_msg = 'Arrays do not match'\nheader = 'Items are not equal:'\nverbose = True\nnames = ('ACTUAL', 'DESIRED')\nprecision = 8",
  "needimport": "import numpy as np\nfrom numpy import array\n\n",
  "test_results": {
    "ans1": "\nItems are not equal: There is a mismatch\n ACTUAL: array([1.00001, 2.00002, 3.00003])\n DESIRED: array([1.00002, 2.00003, 3.00004])",
    "ans2": "\nComparison failed: There is a mismatch",
    "ans3": "\nItems are not equal: There is a mismatch\n FOO: array([1.00001, 2.00002, 3.00003])\n BAR: array([1.00002, 2.00003, 3.00004])",
    "ans4": "\nComparison failed: Mismatch detected\n ACTUAL: array([1.00001, 2.00002, 3.00003])\n EXPECTED: array([1.00002, 2.00003, 3.00004])",
    "ans5": "\nItems are not equal: Arrays do not match\n ACTUAL: array([1.00001, 2.00002, 3.00003])\n DESIRED: array([1.00002, 2.00003, 3.00004])"
  }
}