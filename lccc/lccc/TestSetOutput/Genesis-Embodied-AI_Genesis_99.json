{
  "input_header": "def identity_quat():",
  "input_docstring": null,
  "output_code": "def identity_quat():\n    return np.array([1.0, 0.0, 0.0, 0.0])",
  "input_contexts": [
    {
      "id": "Genesis-Embodied-AI_Genesis_99_3",
      "input_code": "    def _load_mesh(self, morph, surface):\n        if morph.fixed:\n            joint_type = gs.JOINT_TYPE.FIXED\n            n_qs = 0\n            n_dofs = 0\n            init_qpos = np.zeros(0)\n\n        else:\n            joint_type = gs.JOINT_TYPE.FREE\n            n_qs = 7\n            n_dofs = 6\n            init_qpos = np.concatenate([morph.pos, morph.quat])\n        link_name = morph.file.split(\"/\")[-1].replace(\".\", \"_\")\n\n        link = self._add_link(\n            name=f\"{link_name}_baselink\",\n            pos=np.array(morph.pos),\n            quat=np.array(morph.quat),\n            inertial_pos=None,\n            inertial_quat=gu.identity_quat(),\n            inertial_i=None,\n            inertial_mass=None,\n            parent_idx=-1,\n            invweight=None,\n        )\n        self._add_joint(\n            name=f\"{link_name}_baselink_joint\",\n            n_qs=n_qs,\n            n_dofs=n_dofs,\n            type=joint_type,\n            pos=gu.zero_pos(),\n            quat=gu.identity_quat(),\n            dofs_motion_ang=gu.default_dofs_motion_ang(n_dofs),\n            dofs_motion_vel=gu.default_dofs_motion_vel(n_dofs),\n            dofs_limit=gu.default_dofs_limit(n_dofs),\n            dofs_invweight=gu.default_dofs_invweight(n_dofs),\n            dofs_stiffness=gu.default_dofs_stiffness(n_dofs),\n            dofs_sol_params=gu.default_solver_params(n_dofs),\n            dofs_damping=gu.free_dofs_damping(n_dofs),\n            dofs_armature=gu.free_dofs_armature(n_dofs),\n            dofs_kp=gu.default_dofs_kp(n_dofs),\n            dofs_kv=gu.default_dofs_kv(n_dofs),\n            dofs_force_range=gu.default_dofs_force_range(n_dofs),\n            init_qpos=init_qpos,\n        )\n\n        vmeshes, meshes = mu.parse_visual_and_col_mesh(morph, surface)\n\n        if morph.visualization:\n            for vmesh in vmeshes:\n                link._add_vgeom(\n                    vmesh=vmesh,\n                    init_pos=gu.zero_pos(),\n                    init_quat=gu.identity_quat(),\n                )\n\n        if morph.collision:\n            for mesh in meshes:\n                link._add_geom(\n                    mesh=mesh,\n                    init_pos=gu.zero_pos(),\n                    init_quat=gu.identity_quat(),\n                    type=gs.GEOM_TYPE.MESH,\n                    friction=gu.default_friction() if self.material.friction is None else self.material.friction,\n                    sol_params=gu.default_solver_params(n=1)[0],\n                    needs_coup=self.material.needs_coup,\n                )\n"
    },
    {
      "id": "Genesis-Embodied-AI_Genesis_99_6",
      "input_code": "def parse_urdf(morph, surface):\n    if isinstance(morph.file, str):\n        path = os.path.join(get_assets_dir(), morph.file)\n        robot = urdfpy.URDF.load(path)\n    else:\n        robot = morph.file\n\n    if hasattr(morph, \"merge_fixed_links\") and morph.merge_fixed_links:\n        robot = merge_fixed_links(robot, morph.links_to_keep)\n\n    link_name_to_idx = dict()\n    for idx, link in enumerate(robot.links):\n        link_name_to_idx[link.name] = idx\n\n    n_links = len(robot.links)\n    assert n_links == len(robot.joints) + 1\n    l_infos = [dict() for _ in range(n_links)]\n    j_infos = [dict() for _ in range(n_links)]\n\n    for i in range(n_links):\n        link = robot.links[i]\n        l_info = l_infos[i]\n        l_info[\"name\"] = link.name\n\n        l_info[\"invweight\"] = -1.0\n\n        if link.inertial is None:\n            l_info[\"inertial_pos\"] = gu.zero_pos()\n            l_info[\"inertial_quat\"] = gu.identity_quat()\n            l_info[\"inertial_i\"] = None\n            l_info[\"inertial_mass\"] = None\n\n        else:\n            l_info[\"inertial_pos\"] = link.inertial.origin[:3, 3]\n            l_info[\"inertial_quat\"] = gu.R_to_quat(link.inertial.origin[:3, :3])\n            l_info[\"inertial_i\"] = link.inertial.inertia\n            l_info[\"inertial_mass\"] = link.inertial.mass\n\n        l_info[\"g_infos\"] = list()\n\n        for geom in link.collisions + link.visuals:\n            geom_is_col = not isinstance(geom, urdfpy.Visual)\n            if isinstance(geom.geometry.geometry, urdfpy.Mesh):\n                for tmesh in geom.geometry.meshes:\n                    scale = morph.scale\n                    if geom.geometry.geometry.scale is not None:\n                        scale *= geom.geometry.geometry.scale\n\n                    mesh = gs.Mesh.from_trimesh(\n                        tmesh,\n                        scale=scale,\n                        convexify=geom_is_col and morph.convexify,\n                        surface=gs.surfaces.Collision() if geom_is_col else surface,\n                        metadata={\n                            \"mesh_path\": urdfpy.utils.get_filename(\n                                os.path.dirname(path), geom.geometry.geometry.filename\n                            )\n                        },\n                    )\n\n                    if not geom_is_col and (morph.prioritize_urdf_material or not tmesh.visual.defined):\n                        if geom.material is not None and geom.material.color is not None:\n                            mesh.set_color(geom.material.color)\n\n                    geom_type = gs.GEOM_TYPE.MESH\n\n                    g_info = {\n                        \"type\": geom_type,\n                        \"data\": None,\n                        \"pos\": geom.origin[:3, 3].copy(),\n                        \"quat\": gu.R_to_quat(geom.origin[:3, :3]),\n                        \"mesh\": mesh,\n                        \"is_col\": geom_is_col,\n                    }\n                    l_info[\"g_infos\"].append(g_info)\n            else:\n                if isinstance(geom.geometry.geometry, urdfpy.Box):\n                    tmesh = trimesh.creation.box(extents=geom.geometry.geometry.size)\n                    geom_type = gs.GEOM_TYPE.BOX\n                    geom_data = np.array(geom.geometry.geometry.size)\n\n                elif isinstance(geom.geometry.geometry, urdfpy.Cylinder):\n                    tmesh = trimesh.creation.cylinder(\n                        radius=geom.geometry.geometry.radius, height=geom.geometry.geometry.length\n                    )\n                    geom_type = gs.GEOM_TYPE.CYLINDER\n                    geom_data = None\n\n                elif isinstance(geom.geometry.geometry, urdfpy.Sphere):\n                    if geom_is_col:\n                        tmesh = trimesh.creation.icosphere(radius=geom.geometry.geometry.radius, subdivisions=2)\n                    else:\n                        tmesh = trimesh.creation.icosphere(radius=geom.geometry.geometry.radius)\n                    geom_type = gs.GEOM_TYPE.SPHERE\n                    geom_data = np.array([geom.geometry.geometry.radius])\n\n                mesh = gs.Mesh.from_trimesh(\n                    tmesh,\n                    scale=morph.scale,\n                    surface=gs.surfaces.Collision() if geom_is_col else surface,\n                    convexify=True,\n                )\n\n                if not geom_is_col:\n                    if geom.material is not None and geom.material.color is not None:\n                        mesh.set_color(geom.material.color)\n\n                g_info = {\n                    \"type\": geom_type,\n                    \"data\": geom_data,\n                    \"pos\": geom.origin[:3, 3],\n                    \"quat\": gu.R_to_quat(geom.origin[:3, :3]),\n                    \"mesh\": mesh,\n                    \"is_col\": geom_is_col,\n                }\n                l_info[\"g_infos\"].append(g_info)\n\n    for joint in robot.joints:\n        idx = link_name_to_idx[joint.child]\n        l_info = l_infos[idx]\n        j_info = j_infos[idx]\n\n        j_info[\"name\"] = joint.name\n        j_info[\"pos\"] = gu.zero_pos()\n        j_info[\"quat\"] = gu.identity_quat()\n\n        l_info[\"parent_idx\"] = link_name_to_idx[joint.parent]\n        l_info[\"pos\"] = joint.origin[:3, 3]\n        l_info[\"quat\"] = gu.R_to_quat(joint.origin[:3, :3])\n\n        if joint.joint_type == \"fixed\":\n            j_info[\"dofs_motion_ang\"] = np.zeros((0, 3))\n            j_info[\"dofs_motion_vel\"] = np.zeros((0, 3))\n            j_info[\"dofs_limit\"] = np.zeros((0, 2))\n            j_info[\"dofs_stiffness\"] = np.zeros((0))\n\n            j_info[\"type\"] = gs.JOINT_TYPE.FIXED\n            j_info[\"n_qs\"] = 0\n            j_info[\"n_dofs\"] = 0\n            j_info[\"init_qpos\"] = np.zeros(0)\n\n        elif joint.joint_type == \"revolute\":\n            j_info[\"dofs_motion_ang\"] = np.array([joint.axis])\n            j_info[\"dofs_motion_vel\"] = np.zeros((1, 3))\n            j_info[\"dofs_limit\"] = np.array(\n                [\n                    [\n                        joint.limit.lower if joint.limit.lower is not None else -np.inf,\n                        joint.limit.upper if joint.limit.upper is not None else np.inf,\n                    ]\n                ]\n            )\n            j_info[\"dofs_stiffness\"] = np.array([0.0])\n\n            j_info[\"type\"] = gs.JOINT_TYPE.REVOLUTE\n            j_info[\"n_qs\"] = 1\n            j_info[\"n_dofs\"] = 1\n            j_info[\"init_qpos\"] = np.zeros(1)\n\n        elif joint.joint_type == \"continuous\":\n            j_info[\"dofs_motion_ang\"] = np.array([joint.axis])\n            j_info[\"dofs_motion_vel\"] = np.zeros((1, 3))\n            j_info[\"dofs_limit\"] = np.array([[-np.inf, np.inf]])\n            j_info[\"dofs_stiffness\"] = np.array([0.0])\n\n            j_info[\"type\"] = gs.JOINT_TYPE.REVOLUTE\n            j_info[\"n_qs\"] = 1\n            j_info[\"n_dofs\"] = 1\n            j_info[\"init_qpos\"] = np.zeros(1)\n\n        elif joint.joint_type == \"prismatic\":\n            j_info[\"dofs_motion_ang\"] = np.zeros((1, 3))\n            j_info[\"dofs_motion_vel\"] = np.array([joint.axis])\n            j_info[\"dofs_limit\"] = np.array(\n                [\n                    [\n                        joint.limit.lower if joint.limit.lower is not None else -np.inf,\n                        joint.limit.upper if joint.limit.upper is not None else np.inf,\n                    ]\n                ]\n            )\n            j_info[\"dofs_stiffness\"] = np.array([0.0])\n\n            j_info[\"type\"] = gs.JOINT_TYPE.PRISMATIC\n            j_info[\"n_qs\"] = 1\n            j_info[\"n_dofs\"] = 1\n            j_info[\"init_qpos\"] = np.zeros(1)\n\n        elif joint.joint_type == \"floating\":\n            j_info[\"dofs_motion_ang\"] = np.eye(6, 3, -3)\n            j_info[\"dofs_motion_vel\"] = np.eye(6, 3)\n            j_info[\"dofs_limit\"] = np.tile([-np.inf, np.inf], (6, 1))\n            j_info[\"dofs_stiffness\"] = np.zeros(6)\n\n            j_info[\"type\"] = gs.JOINT_TYPE.FREE\n            j_info[\"n_qs\"] = 7\n            j_info[\"n_dofs\"] = 6\n            j_info[\"init_qpos\"] = np.concatenate([gu.zero_pos(), gu.identity_quat()])\n\n        else:\n            gs.raise_exception(f\"Unsupported URDF joint type: {joint.joint_type}\")\n\n\n        j_info[\"dofs_invweight\"] = gu.default_dofs_invweight(j_info[\"n_dofs\"])\n        j_info[\"dofs_sol_params\"] = gu.default_solver_params(j_info[\"n_dofs\"])\n        j_info[\"dofs_kp\"] = gu.default_dofs_kp(j_info[\"n_dofs\"])\n        j_info[\"dofs_kv\"] = gu.default_dofs_kv(j_info[\"n_dofs\"])\n        j_info[\"dofs_force_range\"] = gu.default_dofs_force_range(j_info[\"n_dofs\"])\n\n        if joint.joint_type in [\"floating\", \"fixed\"]:\n            j_info[\"dofs_damping\"] = gu.free_dofs_damping(j_info[\"n_dofs\"])\n            j_info[\"dofs_armature\"] = gu.free_dofs_armature(j_info[\"n_dofs\"])\n        else:\n            j_info[\"dofs_damping\"] = gu.default_dofs_damping(j_info[\"n_dofs\"])\n            j_info[\"dofs_armature\"] = gu.default_dofs_armature(j_info[\"n_dofs\"])\n\n        if joint.safety_controller is not None:\n            if joint.safety_controller.k_position is not None:\n                j_info[\"dofs_kp\"] = np.tile(joint.safety_controller.k_position, j_info[\"n_dofs\"])\n            if joint.safety_controller.k_velocity is not None:\n                j_info[\"dofs_kv\"] = np.tile(joint.safety_controller.k_velocity, j_info[\"n_dofs\"])\n\n        if joint.limit is not None:\n            if joint.limit.effort is not None:\n                j_info[\"dofs_force_range\"] = (\n                    j_info[\"dofs_force_range\"] / np.abs(j_info[\"dofs_force_range\"]) * joint.limit.effort\n                )\n\n    l_infos, j_infos, _ = _order_links(l_infos, j_infos)\n    j_info = j_infos[0]\n    l_info = l_infos[0]\n\n    j_info[\"pos\"] = gu.zero_pos()\n    j_info[\"quat\"] = gu.identity_quat()\n    j_info[\"name\"] = f'joint_{l_info[\"name\"]}'\n\n    l_info[\"pos\"] = gu.zero_pos()\n    l_info[\"quat\"] = gu.identity_quat()\n\n    if not morph.fixed:\n        j_info[\"dofs_motion_ang\"] = np.eye(6, 3, -3)\n        j_info[\"dofs_motion_vel\"] = np.eye(6, 3)\n        j_info[\"dofs_limit\"] = np.tile([-np.inf, np.inf], (6, 1))\n        j_info[\"dofs_stiffness\"] = np.zeros(6)\n\n        j_info[\"type\"] = gs.JOINT_TYPE.FREE\n        j_info[\"n_qs\"] = 7\n        j_info[\"n_dofs\"] = 6\n        j_info[\"init_qpos\"] = np.concatenate([gu.zero_pos(), gu.identity_quat()])\n    else:\n        j_info[\"dofs_motion_ang\"] = np.zeros((0, 3))\n        j_info[\"dofs_motion_vel\"] = np.zeros((0, 3))\n        j_info[\"dofs_limit\"] = np.zeros((0, 2))\n        j_info[\"dofs_stiffness\"] = np.zeros((0))\n\n        j_info[\"type\"] = gs.JOINT_TYPE.FIXED\n        j_info[\"n_qs\"] = 0\n        j_info[\"n_dofs\"] = 0\n        j_info[\"init_qpos\"] = np.zeros(0)\n\n    j_info[\"dofs_invweight\"] = gu.default_dofs_invweight(j_info[\"n_dofs\"])\n    j_info[\"dofs_damping\"] = gu.free_dofs_damping(j_info[\"n_dofs\"])\n    j_info[\"dofs_armature\"] = gu.free_dofs_armature(j_info[\"n_dofs\"])\n    j_info[\"dofs_sol_params\"] = gu.default_solver_params(j_info[\"n_dofs\"])\n\n    j_info[\"dofs_kp\"] = gu.default_dofs_kp(j_info[\"n_dofs\"])\n    j_info[\"dofs_kv\"] = gu.default_dofs_kv(j_info[\"n_dofs\"])\n    j_info[\"dofs_force_range\"] = gu.default_dofs_force_range(j_info[\"n_dofs\"])\n\n    for l_info in l_infos:\n        l_info[\"pos\"] *= morph.scale\n        l_info[\"inertial_pos\"] *= morph.scale\n\n        if l_info[\"inertial_mass\"] is not None:\n            l_info[\"inertial_mass\"] *= morph.scale**3\n        if l_info[\"inertial_i\"] is not None:\n            l_info[\"inertial_i\"] *= morph.scale**5\n\n        for g_info in l_info[\"g_infos\"]:\n            g_info[\"pos\"] *= morph.scale\n\n            g_info[\"friction\"] = gu.default_friction()\n            g_info[\"sol_params\"] = gu.default_solver_params(n=1)[0]\n\n    for j_info in j_infos:\n        j_info[\"pos\"] *= morph.scale\n\n    return l_infos, j_infos\n"
    },
    {
      "id": "Genesis-Embodied-AI_Genesis_99_2",
      "input_code": "    def _load_primitive(self, morph, surface):\n        if morph.fixed:\n            joint_type = gs.JOINT_TYPE.FIXED\n            n_qs = 0\n            n_dofs = 0\n            init_qpos = np.zeros(0)\n\n        else:\n            joint_type = gs.JOINT_TYPE.FREE\n            n_qs = 7\n            n_dofs = 6\n            init_qpos = np.concatenate([morph.pos, morph.quat])\n\n        if isinstance(morph, gs.options.morphs.Box):\n            extents = np.array(morph.size)\n            tmesh = mu.create_box(extents=extents)\n            geom_data = extents\n            geom_type = gs.GEOM_TYPE.BOX\n            link_name_prefix = \"box\"\n\n        elif isinstance(morph, gs.options.morphs.Sphere):\n            tmesh = mu.create_sphere(radius=morph.radius)\n            geom_data = np.array([morph.radius])\n            geom_type = gs.GEOM_TYPE.SPHERE\n            link_name_prefix = \"sphere\"\n\n        elif isinstance(morph, gs.options.morphs.Cylinder):\n            tmesh = mu.create_cylinder(radius=morph.radius, height=morph.height)\n            geom_data = None\n            geom_type = gs.GEOM_TYPE.MESH\n            link_name_prefix = \"cylinder\"\n\n        elif isinstance(morph, gs.options.morphs.Plane):\n            tmesh = mu.create_plane(normal=morph.normal)\n            geom_data = np.array(morph.normal)\n            geom_type = gs.GEOM_TYPE.PLANE\n            link_name_prefix = \"plane\"\n\n        else:\n            gs.raise_exception(\"Unsupported primitive shape\")\n\n        vmesh = gs.Mesh.from_trimesh(tmesh, surface=surface)\n        mesh = gs.Mesh.from_trimesh(tmesh, surface=gs.surfaces.Collision())\n\n        link = self._add_link(\n            name=f\"{link_name_prefix}_baselink\",\n            pos=np.array(morph.pos),\n            quat=np.array(morph.quat),\n            inertial_pos=gu.zero_pos(),\n            inertial_quat=gu.identity_quat(),\n            inertial_i=None,\n            inertial_mass=None,\n            parent_idx=-1,\n            invweight=None,\n        )\n        self._add_joint(\n            name=f\"{link_name_prefix}_baselink_joint\",\n            n_qs=n_qs,\n            n_dofs=n_dofs,\n            type=joint_type,\n            pos=gu.zero_pos(),\n            quat=gu.identity_quat(),\n            dofs_motion_ang=gu.default_dofs_motion_ang(n_dofs),\n            dofs_motion_vel=gu.default_dofs_motion_vel(n_dofs),\n            dofs_limit=gu.default_dofs_limit(n_dofs),\n            dofs_invweight=gu.default_dofs_invweight(n_dofs),\n            dofs_stiffness=gu.default_dofs_stiffness(n_dofs),\n            dofs_sol_params=gu.default_solver_params(n_dofs),\n            dofs_damping=gu.free_dofs_damping(n_dofs),\n            dofs_armature=gu.free_dofs_armature(n_dofs),\n            dofs_kp=gu.default_dofs_kp(n_dofs),\n            dofs_kv=gu.default_dofs_kv(n_dofs),\n            dofs_force_range=gu.default_dofs_force_range(n_dofs),\n            init_qpos=init_qpos,\n        )\n\n        if morph.visualization:\n            link._add_vgeom(\n                vmesh=vmesh,\n                init_pos=gu.zero_pos(),\n                init_quat=gu.identity_quat(),\n            )\n        if morph.collision:\n            link._add_geom(\n                mesh=mesh,\n                init_pos=gu.zero_pos(),\n                init_quat=gu.identity_quat(),\n                type=geom_type,\n                friction=gu.default_friction() if self.material.friction is None else self.material.friction,\n                sol_params=gu.default_solver_params(n=1)[0],\n                data=geom_data,\n                needs_coup=self.material.needs_coup,\n            )\n"
    },
    {
      "id": "Genesis-Embodied-AI_Genesis_99_4",
      "input_code": "    def _load_terrain(self, morph, surface):\n        link = self._add_link(\n            name=\"baselink\",\n            pos=np.array(morph.pos),\n            quat=np.array(morph.quat),\n            inertial_pos=None,\n            inertial_quat=gu.identity_quat(),\n            inertial_i=None,\n            inertial_mass=None,\n            parent_idx=-1,\n            invweight=None,\n        )\n        self._add_joint(\n            name=\"joint_baselink\",\n            n_qs=0,\n            n_dofs=0,\n            type=gs.JOINT_TYPE.FIXED,\n            pos=gu.zero_pos(),\n            quat=gu.identity_quat(),\n            dofs_motion_ang=gu.default_dofs_motion_ang(0),\n            dofs_motion_vel=gu.default_dofs_motion_vel(0),\n            dofs_limit=gu.default_dofs_limit(0),\n            dofs_invweight=gu.default_dofs_invweight(0),\n            dofs_stiffness=gu.default_dofs_stiffness(0),\n            dofs_sol_params=gu.default_solver_params(0),\n            dofs_damping=gu.free_dofs_damping(0),\n            dofs_armature=gu.free_dofs_armature(0),\n            dofs_kp=gu.default_dofs_kp(0),\n            dofs_kv=gu.default_dofs_kv(0),\n            dofs_force_range=gu.default_dofs_force_range(0),\n            init_qpos=np.zeros(0),\n        )\n\n        vmesh, mesh, self.terrain_hf = tu.parse_terrain(morph, surface)\n        self.terrain_scale = np.array([morph.horizontal_scale, morph.vertical_scale])\n\n        if morph.visualization:\n            link._add_vgeom(\n                vmesh=vmesh,\n                init_pos=gu.zero_pos(),\n                init_quat=gu.identity_quat(),\n            )\n\n        if morph.collision:\n            link._add_geom(\n                mesh=mesh,\n                init_pos=gu.zero_pos(),\n                init_quat=gu.identity_quat(),\n                type=gs.GEOM_TYPE.TERRAIN,\n                friction=gu.default_friction() if self.material.friction is None else self.material.friction,\n                sol_params=gu.default_solver_params(n=1)[0],\n                needs_coup=self.material.needs_coup,\n            )\n"
    },
    {
      "id": "Genesis-Embodied-AI_Genesis_99_1",
      "input_code": "def augment_link_world_coords(part_rigid):\n    ordered_links_idx = [link.idx for link in part_rigid.links]\n    for i, i_l_global in enumerate(ordered_links_idx):\n        i_l = i_l_global - part_rigid.link_start\n        link = part_rigid.links[i_l]\n        i_p = link.parent_idx\n\n        parent_pos = np.zeros((3,))\n        parent_quat = gu.identity_quat()\n\n        if i_p != -1:\n            link_p = part_rigid.links[i_p - part_rigid.link_start]\n            parent_pos = link_p.init_x_pos\n            parent_quat = link_p.init_x_quat\n\n        link_is_fixed = link.joint.type == gs.JOINT_TYPE.FIXED\n        if link.joint.type == gs.JOINT_TYPE.FREE or (link_is_fixed and i_p == -1):\n            link.init_x_pos = link.pos\n            link.init_x_quat = link.quat\n        else:\n            link.init_x_pos, link.init_x_quat = gu.transform_pos_quat_by_trans_quat(\n                link.pos, link.quat, parent_pos, parent_quat\n            )\n            link.init_x_pos, link.init_x_quat = gu.transform_pos_quat_by_trans_quat(\n                link.joint.pos, link.joint.quat, link.init_x_pos, link.init_x_quat\n            )\n"
    },
    {
      "id": "Genesis-Embodied-AI_Genesis_99_5",
      "input_code": "    def inverse_kinematics_multilink(\n        self,\n        links,\n        poss=[],\n        quats=[],\n        init_qpos=None,\n        respect_joint_limit=True,\n        max_samples=50,\n        max_solver_iters=20,\n        damping=0.01,\n        pos_tol=5e-4,        rot_tol=5e-3,        pos_mask=[True, True, True],\n        rot_mask=[True, True, True],\n        max_step_size=0.5,\n        dofs_idx_local=None,\n        return_error=False,\n    ):\n        \n\n        if not self._requires_jac_and_IK:\n            gs.raise_exception(\n                \"Inverse kinematics and jacobian are disabled for this entity. Set `morph.requires_jac_and_IK` to True if you need them.\"\n            )\n\n        if self.n_dofs == 0:\n            gs.raise_exception(\"Entity has zero dofs.\")\n\n        n_links = len(links)\n        if n_links == 0:\n            gs.raise_exception(\"Target link not provided.\")\n\n        if len(poss) == 0:\n            poss = [None] * n_links\n            pos_mask = [False, False, False]\n        elif len(poss) != n_links:\n            gs.raise_exception(\"Accepting only `poss` with length equal to `links` or empty list.\")\n\n        if len(quats) == 0:\n            quats = [None] * n_links\n            rot_mask = [False, False, False]\n        elif len(quats) != n_links:\n            gs.raise_exception(\"Accepting only `quats` with length equal to `links` or empty list.\")\n\n        link_pos_mask = []\n        link_rot_mask = []\n        for i in range(n_links):\n            if poss[i] is None and quats[i] is None:\n                gs.raise_exception(\"At least one of `poss` or `quats` must be provided.\")\n            if poss[i] is not None:\n                link_pos_mask.append(True)\n                if self._solver.n_envs > 0:\n                    if poss[i].shape[0] != self._solver.n_envs:\n                        gs.raise_exception(\"First dimension of elements in `poss` must be equal to scene.n_envs.\")\n            else:\n                link_pos_mask.append(False)\n                if self._solver.n_envs == 0:\n                    poss[i] = gu.zero_pos()\n                else:\n                    poss[i] = self._solver._batch_array(gu.zero_pos(), True)\n            if quats[i] is not None:\n                link_rot_mask.append(True)\n                if self._solver.n_envs > 0:\n                    if quats[i].shape[0] != self._solver.n_envs:\n                        gs.raise_exception(\"First dimension of elements in `quats` must be equal to scene.n_envs.\")\n            else:\n                link_rot_mask.append(False)\n                if self._solver.n_envs == 0:\n                    quats[i] = gu.identity_quat()\n                else:\n                    quats[i] = self._solver._batch_array(gu.identity_quat(), True)\n\n        if init_qpos is not None:\n            init_qpos = torch.as_tensor(init_qpos, dtype=gs.tc_float)\n            if init_qpos.shape[-1] != self.n_qs:\n                gs.raise_exception(\n                    f\"Size of last dimension `init_qpos` does not match entity's `n_qs`: {init_qpos.shape[-1]} vs {self.n_qs}.\"\n                )\n\n            init_qpos = self._solver._process_dim(init_qpos)\n            custom_init_qpos = True\n\n        else:\n            init_qpos = torch.empty((0, 0), dtype=gs.tc_float)\n            custom_init_qpos = False\n\n        pos_mask = torch.as_tensor(pos_mask, dtype=bool, device=gs.device)\n        if len(pos_mask) != 3:\n            gs.raise_exception(\"`pos_mask` must have length 3.\")\n        rot_mask = torch.as_tensor(rot_mask, dtype=bool, device=gs.device)\n        if len(rot_mask) != 3:\n            gs.raise_exception(\"`rot_mask` must have length 3.\")\n        if sum(rot_mask) == 1:\n            rot_mask = ~rot_mask\n        elif sum(rot_mask) == 2:\n            gs.raise_exception(\"You can only align 0, 1 axis or all 3 axes.\")\n        else:\n            pass\n        link_pos_mask = torch.as_tensor(link_pos_mask, dtype=gs.tc_int, device=gs.device)\n        link_rot_mask = torch.as_tensor(link_rot_mask, dtype=gs.tc_int, device=gs.device)\n\n        links_idx = torch.as_tensor([link.idx for link in links], dtype=gs.tc_int, device=gs.device)\n        poss = torch.stack(\n            [self._solver._process_dim(torch.as_tensor(pos, dtype=gs.tc_float, device=gs.device)) for pos in poss]\n        )\n        quats = torch.stack(\n            [self._solver._process_dim(torch.as_tensor(quat, dtype=gs.tc_float, device=gs.device)) for quat in quats]\n        )\n\n        dofs_idx = self._get_dofs_idx_local(dofs_idx_local)\n        n_dofs = len(dofs_idx)\n        if n_dofs == 0:\n            gs.raise_exception(\"Target dofs not provided.\")\n        links_idx_by_dofs = []\n        for v in self.links:\n            links_idx_by_dof_at_v = v.joint.dof_idx_local\n            if links_idx_by_dof_at_v is None:\n                link_relevant = False\n            elif isinstance(links_idx_by_dof_at_v, list):\n                link_relevant = any([vv in dofs_idx for vv in links_idx_by_dof_at_v])\n            else:\n                link_relevant = links_idx_by_dof_at_v in dofs_idx\n            if link_relevant:\n                links_idx_by_dofs.append(v.idx_local)\n        links_idx_by_dofs = self._get_ls_idx(links_idx_by_dofs)\n        n_links_by_dofs = len(links_idx_by_dofs)\n\n        self._kernel_inverse_kinematics(\n            links_idx,\n            poss,\n            quats,\n            n_links,\n            dofs_idx,\n            n_dofs,\n            links_idx_by_dofs,\n            n_links_by_dofs,\n            custom_init_qpos,\n            init_qpos,\n            max_samples,\n            max_solver_iters,\n            damping,\n            pos_tol,\n            rot_tol,\n            pos_mask,\n            rot_mask,\n            link_pos_mask,\n            link_rot_mask,\n            max_step_size,\n            respect_joint_limit,\n        )\n        qpos = self._IK_qpos_best.to_torch(gs.device).permute(1, 0)\n        if self._solver.n_envs == 0:\n            qpos = qpos.squeeze(0)\n\n        if return_error:\n            error_pose = (\n                self._IK_err_pose_best.to_torch(gs.device)\n                .reshape([self._IK_n_tgts, 6, -1])[:n_links]\n                .permute([2, 0, 1])\n            )\n            if self._solver.n_envs == 0:\n                error_pose = error_pose.squeeze(0)\n            return qpos, error_pose\n\n        else:\n            return qpos\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport numpy as np\n\n<testcase_1>\n\n<testcase_2>\n\n<testcase_3>\n\n<testcase_4>\n\n<testcase_5>"
  ],
  "gpt_output": "<needimport>\nimport numpy as np\n\n<testcase_1>\n\n<testcase_2>\n\n<testcase_3>\n\n<testcase_4>\n\n<testcase_5>",
  "needimport": "import numpy as np\n\n",
  "test_results": {
    "ans1": "[1. 0. 0. 0.]",
    "ans2": "[1. 0. 0. 0.]",
    "ans3": "[1. 0. 0. 0.]",
    "ans4": "[1. 0. 0. 0.]",
    "ans5": "[1. 0. 0. 0.]"
  }
}