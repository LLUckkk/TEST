{
  "input_header": "def _generate_css(attrib):",
  "input_docstring": null,
  "output_code": "def _generate_css(attrib):\n    return \"; \".join(f\"{k}: {v}\" for k, v in attrib.items())",
  "input_contexts": [
    {
      "id": "matplotlib_matplotlib_2581_2",
      "input_code": "    def _write_hatches(self):\n        if not len(self._hatchd):\n            return\n        HATCH_SIZE = 72\n        writer = self.writer\n        writer.start('defs')\n        for (path, face, stroke, lw), oid in self._hatchd.values():\n            writer.start(\n                'pattern',\n                id=oid,\n                patternUnits=\"userSpaceOnUse\",\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE),\n                height=str(HATCH_SIZE))\n            path_data = self._convert_path(\n                path,\n                Affine2D()\n                .scale(HATCH_SIZE).scale(1.0, -1.0).translate(0, HATCH_SIZE),\n                simplify=False)\n            if face is None:\n                fill = 'none'\n            else:\n                fill = rgb2hex(face)\n            writer.element(\n                'rect',\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE+1),\n                height=str(HATCH_SIZE+1),\n                fill=fill)\n            hatch_style = {\n                    'fill': rgb2hex(stroke),\n                    'stroke': rgb2hex(stroke),\n                    'stroke-width': str(lw),\n                    'stroke-linecap': 'butt',\n                    'stroke-linejoin': 'miter'\n                    }\n            if stroke[3] < 1:\n                hatch_style['stroke-opacity'] = str(stroke[3])\n            writer.element(\n                'path',\n                d=path_data,\n                style=_generate_css(hatch_style)\n                )\n            writer.end('pattern')\n        writer.end('defs')\n"
    },
    {
      "id": "matplotlib_matplotlib_2581_1",
      "input_code": "    def _write_default_style(self):\n        writer = self.writer\n        default_style = _generate_css({\n            'stroke-linejoin': 'round',\n            'stroke-linecap': 'butt'})\n        writer.start('defs')\n        writer.element('style', type='text/css', text='*{%s}' % default_style)\n        writer.end('defs')\n"
    },
    {
      "id": "matplotlib_matplotlib_2581_6",
      "input_code": "    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map = self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = _short_float_fmt(alpha)\n        font_scale = fontsize / text2path.FONT_SCALE\n        attrib = {\n            'style': _generate_css(style),\n            'transform': _generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))]),\n        }\n        writer.start('g', attrib=attrib)\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                writer.element(\n                    'use',\n                    transform=_generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': f'#{glyph_id}'})\n\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n                writer.element(\n                    'use',\n                    transform=_generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': f'#{char_id}'})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._convert_path(path, simplify=False)\n                writer.element('path', d=path_data)\n\n        writer.end('g')\n"
    },
    {
      "id": "matplotlib_matplotlib_2581_4",
      "input_code": "    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, _generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = _generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        writer.start('g', **self._get_clip_attrs(gc))\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': f'#{oid}'}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = _short_float_fmt(x)\n                attrib['y'] = _short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        if gc.get_url() is not None:\n            self.writer.end('a')\n        writer.end('g')\n"
    },
    {
      "id": "matplotlib_matplotlib_2581_3",
      "input_code": "    def _get_style(self, gc, rgbFace):\n        return _generate_css(self._get_style_dict(gc, rgbFace))\n"
    },
    {
      "id": "matplotlib_matplotlib_2581_5",
      "input_code": "    def _draw_gouraud_triangle(self, transformed_points, colors):\n\n        avg_color = np.average(colors, axis=0)\n        if avg_color[-1] == 0:\n            return\n\n        writer = self.writer\n        writer.start('defs')\n        for i in range(3):\n            x1, y1 = transformed_points[i]\n            x2, y2 = transformed_points[(i + 1) % 3]\n            x3, y3 = transformed_points[(i + 2) % 3]\n            rgba_color = colors[i]\n\n            if x2 == x3:\n                xb = x2\n                yb = y1\n            elif y2 == y3:\n                xb = x1\n                yb = y2\n            else:\n                m1 = (y2 - y3) / (x2 - x3)\n                b1 = y2 - (m1 * x2)\n                m2 = -(1.0 / m1)\n                b2 = y1 - (m2 * x1)\n                xb = (-b1 + b2) / (m1 - m2)\n                yb = m2 * xb + b2\n\n            writer.start(\n                'linearGradient',\n                id=f\"GR{self._n_gradients:x}_{i:d}\",\n                gradientUnits=\"userSpaceOnUse\",\n                x1=_short_float_fmt(x1), y1=_short_float_fmt(y1),\n                x2=_short_float_fmt(xb), y2=_short_float_fmt(yb))\n            writer.element(\n                'stop',\n                offset='1',\n                style=_generate_css({\n                    'stop-color': rgb2hex(avg_color),\n                    'stop-opacity': _short_float_fmt(rgba_color[-1])}))\n            writer.element(\n                'stop',\n                offset='0',\n                style=_generate_css({'stop-color': rgb2hex(rgba_color),\n                                    'stop-opacity': \"0\"}))\n\n            writer.end('linearGradient')\n\n        writer.end('defs')\n\n        dpath = (f\"M {_short_float_fmt(x1)},{_short_float_fmt(y1)}\"\n                 f\" L {_short_float_fmt(x2)},{_short_float_fmt(y2)}\"\n                 f\" {_short_float_fmt(x3)},{_short_float_fmt(y3)} Z\")\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': rgb2hex(avg_color),\n                    'fill-opacity': '1',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.start(\n                'g',\n                attrib={'stroke': \"none\",\n                        'stroke-width': \"0\",\n                        'shape-rendering': \"crispEdges\",\n                        'filter': \"url(#colorMat)\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': f'url(#GR{self._n_gradients:x}_0)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': f'url(#GR{self._n_gradients:x}_1)',\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': f'url(#GR{self._n_gradients:x}_2)',\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.end('g')\n\n        self._n_gradients += 1\n"
    },
    {
      "id": "matplotlib_matplotlib_2581_7",
      "input_code": "    def _draw_text_as_text(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        writer = self.writer\n\n        color = rgb2hex(gc.get_rgb())\n        font_style = {}\n        color_style = {}\n        if color != '#000000':\n            color_style['fill'] = color\n\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            color_style['opacity'] = _short_float_fmt(alpha)\n\n        if not ismath:\n            attrib = {}\n\n            if prop.get_style() != 'normal':\n                font_style['font-style'] = prop.get_style()\n            if prop.get_variant() != 'normal':\n                font_style['font-variant'] = prop.get_variant()\n            weight = fm.weight_dict[prop.get_weight()]\n            if weight != 400:\n                font_style['font-weight'] = f'{weight}'\n\n            def _normalize_sans(name):\n                return 'sans-serif' if name in ['sans', 'sans serif'] else name\n\n            def _expand_family_entry(fn):\n                fn = _normalize_sans(fn)\n                if fn in fm.font_family_aliases:\n                    for name in fm.FontManager._expand_aliases(fn):\n                        yield _normalize_sans(name)\n                yield fn\n\n            def _get_all_quoted_names(prop):\n                return [name if name in fm.font_family_aliases else repr(name)\n                        for entry in prop.get_family()\n                        for name in _expand_family_entry(entry)]\n\n            font_style['font-size'] = f'{_short_float_fmt(prop.get_size())}px'\n            font_style['font-family'] = \", \".join(\n                dict.fromkeys(_get_all_quoted_names(prop))\n                )\n\n            if prop.get_stretch() != 'normal':\n                font_style['font-stretch'] = prop.get_stretch()\n            attrib['style'] = _generate_css({**font_style, **color_style})\n\n            if mtext and (angle == 0 or mtext.get_rotation_mode() == \"anchor\"):\n\n                transform = mtext.get_transform()\n                ax, ay = transform.transform(mtext.get_unitless_position())\n                ay = self.height - ay\n\n                angle_rad = np.deg2rad(angle)\n                dir_vert = np.array([np.sin(angle_rad), np.cos(angle_rad)])\n                v_offset = np.dot(dir_vert, [(x - ax), (y - ay)])\n                ax = ax + v_offset * dir_vert[0]\n                ay = ay + v_offset * dir_vert[1]\n\n                ha_mpl_to_svg = {'left': 'start', 'right': 'end',\n                                 'center': 'middle'}\n                font_style['text-anchor'] = ha_mpl_to_svg[mtext.get_ha()]\n\n                attrib['x'] = _short_float_fmt(ax)\n                attrib['y'] = _short_float_fmt(ay)\n                attrib['style'] = _generate_css({**font_style, **color_style})\n                attrib['transform'] = _generate_transform([\n                    (\"rotate\", (-angle, ax, ay))])\n\n            else:\n                attrib['transform'] = _generate_transform([\n                    ('translate', (x, y)),\n                    ('rotate', (-angle,))])\n\n            writer.element('text', s, attrib=attrib)\n\n        else:\n            writer.comment(s)\n\n            width, height, descent, glyphs, rects = \\\n                self._text2path.mathtext_parser.parse(s, 72, prop)\n\n            writer.start('g',\n                         style=_generate_css({**font_style, **color_style}),\n                         transform=_generate_transform([\n                             ('translate', (x, y)),\n                             ('rotate', (-angle,))]),\n                         )\n\n            writer.start('text')\n\n            spans = {}\n            for font, fontsize, thetext, new_x, new_y in glyphs:\n                entry = fm.ttfFontProperty(font)\n                font_style = {}\n                if entry.style != 'normal':\n                    font_style['font-style'] = entry.style\n                if entry.variant != 'normal':\n                    font_style['font-variant'] = entry.variant\n                if entry.weight != 400:\n                    font_style['font-weight'] = f'{entry.weight}'\n                font_style['font-size'] = f'{_short_float_fmt(fontsize)}px'\n                font_style['font-family'] = f'{entry.name!r}'\n                if entry.stretch != 'normal':\n                    font_style['font-stretch'] = entry.stretch\n                style = _generate_css({**font_style, **color_style})\n                if thetext == 32:\n                    thetext = 0xa0\n                spans.setdefault(style, []).append((new_x, -new_y, thetext))\n\n            for style, chars in spans.items():\n                chars.sort()\n                for x, y, t in chars:\n                    writer.element(\n                        'tspan',\n                        chr(t),\n                        x=_short_float_fmt(x),\n                        y=_short_float_fmt(y),\n                        style=style)\n\n            writer.end('text')\n\n            for x, y, width, height in rects:\n                writer.element(\n                    'rect',\n                    x=_short_float_fmt(x),\n                    y=_short_float_fmt(-y-1),\n                    width=_short_float_fmt(width),\n                    height=_short_float_fmt(height)\n                    )\n\n            writer.end('g')\n"
    }
  ],
  "generated_inputs": [
    "<needimport>\nimport matplotlib.colors as mcolors\n\n<testcase_1>\nattrib = {\n    'color': 'blue',\n    'font-size': '12px',\n    'font-weight': 'bold'\n}\n\n<testcase_2>\nattrib = {\n    'background-color': '#ffcc00',\n    'border': '1px solid black',\n    'padding': '5px'\n}\n\n<testcase_3>\nattrib = {\n    'stroke': mcolors.to_hex((0.5, 0.2, 0.8)),\n    'stroke-width': '2',\n    'fill': 'none'\n}\n\n<testcase_4>\nattrib = {\n    'opacity': '0.5',\n    'visibility': 'hidden',\n    'display': 'block'\n}\n\n<testcase_5>\nattrib = {\n    'text-align': 'center',\n    'line-height': '1.5',\n    'margin': '10px 20px'\n}"
  ],
  "gpt_output": "<needimport>\nimport matplotlib.colors as mcolors\n\n<testcase_1>\nattrib = {\n    'color': 'blue',\n    'font-size': '12px',\n    'font-weight': 'bold'\n}\n\n<testcase_2>\nattrib = {\n    'background-color': '#ffcc00',\n    'border': '1px solid black',\n    'padding': '5px'\n}\n\n<testcase_3>\nattrib = {\n    'stroke': mcolors.to_hex((0.5, 0.2, 0.8)),\n    'stroke-width': '2',\n    'fill': 'none'\n}\n\n<testcase_4>\nattrib = {\n    'opacity': '0.5',\n    'visibility': 'hidden',\n    'display': 'block'\n}\n\n<testcase_5>\nattrib = {\n    'text-align': 'center',\n    'line-height': '1.5',\n    'margin': '10px 20px'\n}",
  "needimport": "import matplotlib.colors as mcolors\n\n",
  "test_results": {
    "ans1": "color: blue; font-size: 12px; font-weight: bold",
    "ans2": "background-color: #ffcc00; border: 1px solid black; padding: 5px",
    "ans3": "stroke: #8033cc; stroke-width: 2; fill: none",
    "ans4": "opacity: 0.5; visibility: hidden; display: block",
    "ans5": "text-align: center; line-height: 1.5; margin: 10px 20px"
  }
}